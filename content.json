[{"title":"Koa","date":"2018-09-04T03:02:48.000Z","path":"09-04-Koa/","text":"# 基于 Node.js 平台的下一代 web 开发框架Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 基本用法架设 HTTP 服务只要三行代码，就可以用 Koa 架设一个 HTTP 服务。 1234const Koa = require('koa');const app = new Koa();app.listen(3000); Context 对象Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。Context.response.body属性就是发送给用户的内容。 123456789const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); main函数用来设置ctx.response.body。然后，使用app.use方法加载main函数。你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。 HTTP Response 的类型Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型。 1234567891011121314 if (ctx.request.accepts('xml')) &#123; ctx.response.type = 'xml'; ctx.response.body = '&lt;data&gt;Hello World&lt;/data&gt;'; &#125; else if (ctx.request.accepts('json')) &#123; ctx.response.type = 'json'; ctx.response.body = &#123; data: 'Hello World' &#125;; &#125; else if (ctx.request.accepts('html')) &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Hello World&lt;/p&gt;'; &#125; else &#123; ctx.response.type = 'text'; ctx.response.body = 'Hello World'; &#125;&#125;; 网页模板实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。 1234567891011const fs = require('fs');const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = fs.createReadStream('./demos/template.html');&#125;;app.use(main);app.listen(3000); 路由原生路由网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。 1234567891011121314const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; if (ctx.request.path !== '/') &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;'; &#125; else &#123; ctx.response.body = 'Hello World'; &#125;&#125;;app.use(main);app.listen(3000); koa-route 模块原生路由用起来不太方便，我们可以使用封装好的koa-route模块。 1234567891011121314151617const Koa = require('koa');const route = require('koa-route');const app = new Koa();const about = ctx =&gt; &#123; ctx.response.type = 'html'; ctx.response.body = '&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;';&#125;;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(route.get('/', main));app.use(route.get('/about', about));app.listen(3000); 静态资源如果网站提供静态资源（图片、字体、样式表、脚本……），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求。 123456789const Koa = require('koa');const app = new Koa();const path = require('path');const serve = require('koa-static');const main = serve(path.join(__dirname));app.use(main);app.listen(3000); 重定向有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。 1234567891011121314151617const Koa = require('koa');const route = require('koa-route');const app = new Koa();const redirect = ctx =&gt; &#123; ctx.response.redirect('/');&#125;;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(route.get('/', main));app.use(route.get('/redirect', redirect));app.use(main);app.listen(3000); 中间件Logger 功能Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。 最简单的写法就是在main函数里面增加一行。 12345678910const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); ctx.response.body = 'Hello World';&#125;;app.use(main);app.listen(3000); 中间件的概念上一个例子里面的 Logger 功能，可以拆分成一个独立函数。 12345678910111213141516const Koa = require('koa');const app = new Koa();const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;app.use(logger);app.use(main);app.listen(3000); 上面代码中的 logger 函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。 基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。 中间件栈多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。 最外层的中间件首先执行。 调用 next 函数，把执行权交给下一个中间件。 … 最内层的中间件最后执行。 执行结束后，把执行权交回上一层的中间件。 … 最外层的中间件收回执行权之后，执行 next 函数后面的代码。 1234567891011121314151617181920212223242526const Koa = require('koa');const app = new Koa();const one = (ctx, next) =&gt; &#123; console.log('&gt;&gt; one'); next(); console.log('&lt;&lt; one');&#125;const two = (ctx, next) =&gt; &#123; console.log('&gt;&gt; two'); next(); console.log('&lt;&lt; two');&#125;const three = (ctx, next) =&gt; &#123; console.log('&gt;&gt; three'); next(); console.log('&lt;&lt; three');&#125;app.use(one);app.use(two);app.use(three);app.listen(3000); 如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。作为练习，你可以将two函数里面next()这一行注释掉再执行，看看会有什么结果。 异步中间件迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。 1234567891011const fs = require('fs.promised');const Koa = require('koa');const app = new Koa();const main = async function (ctx, next) &#123; ctx.response.type = 'html'; ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');&#125;;app.use(main);app.listen(3000); 上面代码中，fs.readFile 是一个异步操作，必须写成 await fs.readFile()，然后中间件必须写成 async 函数。 中间件的合成koa-compose模块可以将多个中间件合成为一个。 123456789101112131415161718const Koa = require('koa');const compose = require('koa-compose');const app = new Koa();const logger = (ctx, next) =&gt; &#123; console.log(`$&#123;Date.now()&#125; $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;`); next();&#125;const main = ctx =&gt; &#123; ctx.response.body = 'Hello World';&#125;;const middlewares = compose([logger, main]);app.use(middlewares);app.listen(3000); 错误处理500 错误如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了 ctx.throw() 方法，用来抛出错误，ctx.throw(500) 就是抛出 500 错误。 123456789const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(main);app.listen(3000); 404错误如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。 12345678910const Koa = require('koa');const app = new Koa();const main = ctx =&gt; &#123; ctx.response.status = 404; ctx.response.body = 'Page Not Found';&#125;;app.use(main);app.listen(3000); 处理错误的中间件为了方便处理错误，最好使用 try…catch 将其捕获。但是，为每个中间件都写 try…catch 太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。 123456789101112131415161718192021const Koa = require('koa');const app = new Koa();const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.body = &#123; message: err.message &#125;; &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.use(handler);app.use(main);app.listen(3000); error 事件的监听运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误。 12345678910111213const app = new Koa();const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', (err, ctx) =&gt; &#123; console.error('server error', err);&#125;);app.use(main);app.listen(3000); 释放 error 事件需要注意的是，如果错误被 try…catch 捕获，就不会触发 error 事件。这时，必须调用 ctx.app.emit()，手动释放 error 事件，才能让监听函数生效。 1234567891011121314151617181920212223242526const Koa = require('koa');const app = new Koa();const handler = async (ctx, next) =&gt; &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.response.status = err.statusCode || err.status || 500; ctx.response.type = 'html'; ctx.response.body = '&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'; ctx.app.emit('error', err, ctx); &#125;&#125;;const main = ctx =&gt; &#123; ctx.throw(500);&#125;;app.on('error', function(err) &#123; console.log('logging error ', err.message); console.log(err);&#125;);app.use(handler);app.use(main);app.listen(3000); 上面代码中，main函数抛出错误，被handler函数捕获。catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。 Web App 的功能Cookiesctx.cookies用来读写 Cookie。 1234567891011const Koa = require('koa');const app = new Koa();const main = function(ctx) &#123; const n = Number(ctx.cookies.get('view') || 0) + 1; ctx.cookies.set('view', n); ctx.response.body = n + ' views';&#125;app.use(main);app.listen(3000); 表单Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对。 12345678910111213const Koa = require('koa');const koaBody = require('koa-body');const app = new Koa();const main = async function(ctx) &#123; const body = ctx.request.body; if (!body.name) ctx.throw(400, '.name required'); ctx.body = &#123; name: body.name &#125;;&#125;;app.use(koaBody());app.use(main);app.listen(3000); 打开另一个命令行窗口，运行下面的命令。 12345$ curl -X POST --data \"name=Jack\" 127.0.0.1:3000// &#123;\"name\":\"Jack\"&#125;$ curl -X POST --data \"name\" 127.0.0.1:3000// name required 上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。 文件上传koa-body模块还可以用来处理文件上传。 1234567891011121314151617181920212223242526272829const os = require('os');const path = require('path');const Koa = require('koa');const fs = require('fs');const koaBody = require('koa-body');const app = new Koa();const main = async function(ctx) &#123; const tmpdir = os.tmpdir(); const filePaths = []; const files = ctx.request.body.files || &#123;&#125;; for (let key in files) &#123; const file = files[key]; const filePath = path.join(tmpdir, file.name); const reader = fs.createReadStream(file.path); const writer = fs.createWriteStream(filePath); reader.pipe(writer); filePaths.push(filePath); &#125; ctx.body = filePaths;&#125;;app.use(koaBody(&#123; multipart: true &#125;));app.use(main);app.listen(3000); 打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，/path/to/file要更换为真实的文件路径。 12$ curl --form upload=@/path/to/file http://127.0.0.1:3000// [\"/tmp/file\"]","raw":"---\ntitle: Koa\ndate: 2018-09-04 11:02:48\ntags: Learning\ncomments: true\ntoc: true\n---\n#\n\n基于 Node.js 平台的下一代 web 开发框架\nKoa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。\n<!-- more -->\n\n## 基本用法\n\n### 架设 HTTP 服务\n\n只要三行代码，就可以用 Koa 架设一个 HTTP 服务。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.listen(3000);\n```\n\n### Context 对象\n\nKoa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。\nContext.response.body属性就是发送给用户的内容。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  ctx.response.body = 'Hello World';\n};\n\napp.use(main);\napp.listen(3000);\n```\n\nmain函数用来设置ctx.response.body。然后，使用app.use方法加载main函数。\n你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。\n\n### HTTP Response 的类型\n\nKoa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型。\n\n```javascript\n  if (ctx.request.accepts('xml')) {\n    ctx.response.type = 'xml';\n    ctx.response.body = '<data>Hello World</data>';\n  } else if (ctx.request.accepts('json')) {\n    ctx.response.type = 'json';\n    ctx.response.body = { data: 'Hello World' };\n  } else if (ctx.request.accepts('html')) {\n    ctx.response.type = 'html';\n    ctx.response.body = '<p>Hello World</p>';\n  } else {\n    ctx.response.type = 'text';\n    ctx.response.body = 'Hello World';\n  }\n};\n```\n\n### 网页模板\n\n实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。\n\n```javascript\nconst fs = require('fs');\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  ctx.response.type = 'html';\n  ctx.response.body = fs.createReadStream('./demos/template.html');\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n## 路由\n\n### 原生路由\n\n网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  if (ctx.request.path !== '/') {\n    ctx.response.type = 'html';\n    ctx.response.body = '<a href=\"/\">Index Page</a>';\n  } else {\n    ctx.response.body = 'Hello World';\n  }\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n### koa-route 模块\n\n原生路由用起来不太方便，我们可以使用封装好的koa-route模块。\n\n```javascript\nconst Koa = require('koa');\nconst route = require('koa-route');\nconst app = new Koa();\n\nconst about = ctx => {\n  ctx.response.type = 'html';\n  ctx.response.body = '<a href=\"/\">Index Page</a>';\n};\n\nconst main = ctx => {\n  ctx.response.body = 'Hello World';\n};\n\napp.use(route.get('/', main));\napp.use(route.get('/about', about));\n\napp.listen(3000);\n```\n\n### 静态资源\n\n如果网站提供静态资源（图片、字体、样式表、脚本......），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\nconst path = require('path');\nconst serve = require('koa-static');\n\nconst main = serve(path.join(__dirname));\n\napp.use(main);\napp.listen(3000);\n```\n\n### 重定向\n\n有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。\n\n```javascript\nconst Koa = require('koa');\nconst route = require('koa-route');\nconst app = new Koa();\n\nconst redirect = ctx => {\n  ctx.response.redirect('/');\n};\n\nconst main = ctx => {\n  ctx.response.body = 'Hello World';\n};\n\napp.use(route.get('/', main));\napp.use(route.get('/redirect', redirect));\n\napp.use(main);\napp.listen(3000);\n```\n\n## 中间件\n\n### Logger 功能\n\nKoa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。\n\n最简单的写法就是在main函数里面增加一行。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  ctx.response.body = 'Hello World';\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n### 中间件的概念\n\n上一个例子里面的 Logger 功能，可以拆分成一个独立函数。\n\n```javascript\n\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst logger = (ctx, next) => {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  next();\n}\n\nconst main = ctx => {\n  ctx.response.body = 'Hello World';\n};\n\napp.use(logger);\napp.use(main);\napp.listen(3000);\n```\n\n上面代码中的 **logger** 函数就叫做\"中间件\"（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。\n\n基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。\n\n### 中间件栈\n\n多个中间件会形成一个栈结构（middle stack），以\"先进后出\"（first-in-last-out）的顺序执行。\n\n1. 最外层的中间件首先执行。\n2. 调用 next 函数，把执行权交给下一个中间件。\n3. ...\n4. 最内层的中间件最后执行。\n5. 执行结束后，把执行权交回上一层的中间件。\n6. ...\n7. 最外层的中间件收回执行权之后，执行 next 函数后面的代码。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst one = (ctx, next) => {\n  console.log('>> one');\n  next();\n  console.log('<< one');\n}\n\nconst two = (ctx, next) => {\n  console.log('>> two');\n  next();\n  console.log('<< two');\n}\n\nconst three = (ctx, next) => {\n  console.log('>> three');\n  next();\n  console.log('<< three');\n}\n\napp.use(one);\napp.use(two);\napp.use(three);\n\napp.listen(3000);\n```\n\n如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。作为练习，你可以将two函数里面next()这一行注释掉再执行，看看会有什么结果。\n\n### 异步中间件\n\n迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。\n\n```javascript\nconst fs = require('fs.promised');\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = async function (ctx, next) {\n  ctx.response.type = 'html';\n  ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n上面代码中，fs.readFile 是一个异步操作，必须写成 await fs.readFile()，然后中间件必须写成 async 函数。\n\n### 中间件的合成\n\nkoa-compose模块可以将多个中间件合成为一个。\n\n```javascript\n\nconst Koa = require('koa');\nconst compose = require('koa-compose');\nconst app = new Koa();\n\nconst logger = (ctx, next) => {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  next();\n}\n\nconst main = ctx => {\n  ctx.response.body = 'Hello World';\n};\n\nconst middlewares = compose([logger, main]);\n\napp.use(middlewares);\napp.listen(3000);\n```\n\n## 错误处理\n\n### 500 错误\n\n如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了 ctx.throw() 方法，用来抛出错误，ctx.throw(500) 就是抛出 500 错误。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  ctx.throw(500);\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n### 404错误\n\n如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = ctx => {\n  ctx.response.status = 404;\n  ctx.response.body = 'Page Not Found';\n};\n\napp.use(main);\napp.listen(3000);\n```\n\n### 处理错误的中间件\n\n为了方便处理错误，最好使用 try...catch 将其捕获。但是，为每个中间件都写 try...catch 太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst handler = async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.response.status = err.statusCode || err.status || 500;\n    ctx.response.body = {\n      message: err.message\n    };\n  }\n};\n\nconst main = ctx => {\n  ctx.throw(500);\n};\n\napp.use(handler);\napp.use(main);\napp.listen(3000);\n```\n\n### error 事件的监听\n\n运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误。\n\n```javascript\n\nconst app = new Koa();\n\nconst main = ctx => {\n  ctx.throw(500);\n};\n\napp.on('error', (err, ctx) => {\n  console.error('server error', err);\n});\n\napp.use(main);\napp.listen(3000);\n```\n\n### 释放 error 事件\n\n需要注意的是，如果错误被 try...catch 捕获，就不会触发 error 事件。这时，必须调用 ctx.app.emit()，手动释放 error 事件，才能让监听函数生效。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst handler = async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    ctx.response.status = err.statusCode || err.status || 500;\n    ctx.response.type = 'html';\n    ctx.response.body = '<p>Something wrong, please contact administrator.</p>';\n    ctx.app.emit('error', err, ctx);\n  }\n};\n\nconst main = ctx => {\n  ctx.throw(500);\n};\n\napp.on('error', function(err) {\n  console.log('logging error ', err.message);\n  console.log(err);\n});\n\napp.use(handler);\napp.use(main);\napp.listen(3000);\n```\n\n上面代码中，main函数抛出错误，被handler函数捕获。catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。\n\n## Web App 的功能\n\n### Cookies\n\nctx.cookies用来读写 Cookie。\n\n```javascript\nconst Koa = require('koa');\nconst app = new Koa();\n\nconst main = function(ctx) {\n  const n = Number(ctx.cookies.get('view') || 0) + 1;\n  ctx.cookies.set('view', n);\n  ctx.response.body = n + ' views';\n}\n\napp.use(main);\napp.listen(3000);\n```\n\n### 表单\n\nWeb 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对。\n\n```javascript\nconst Koa = require('koa');\nconst koaBody = require('koa-body');\nconst app = new Koa();\n\nconst main = async function(ctx) {\n  const body = ctx.request.body;\n  if (!body.name) ctx.throw(400, '.name required');\n  ctx.body = { name: body.name };\n};\n\napp.use(koaBody());\napp.use(main);\napp.listen(3000);\n```\n\n打开另一个命令行窗口，运行下面的命令。\n\n```javascript\n$ curl -X POST --data \"name=Jack\" 127.0.0.1:3000\n// {\"name\":\"Jack\"}\n\n$ curl -X POST --data \"name\" 127.0.0.1:3000\n// name required\n```\n\n上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。\n\n### 文件上传\n\nkoa-body模块还可以用来处理文件上传。\n\n```javascript\n\nconst os = require('os');\nconst path = require('path');\nconst Koa = require('koa');\nconst fs = require('fs');\nconst koaBody = require('koa-body');\n\nconst app = new Koa();\n\nconst main = async function(ctx) {\n  const tmpdir = os.tmpdir();\n  const filePaths = [];\n  const files = ctx.request.body.files || {};\n\n  for (let key in files) {\n    const file = files[key];\n    const filePath = path.join(tmpdir, file.name);\n    const reader = fs.createReadStream(file.path);\n    const writer = fs.createWriteStream(filePath);\n    reader.pipe(writer);\n    filePaths.push(filePath);\n  }\n\n  ctx.body = filePaths;\n};\n\napp.use(koaBody({ multipart: true }));\napp.use(main);\napp.listen(3000);\n```\n\n打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，/path/to/file要更换为真实的文件路径。\n\n```javascript\n$ curl --form upload=@/path/to/file http://127.0.0.1:3000\n// [\"/tmp/file\"]\n```","content":"<p>#</p>\n<p>基于 Node.js 平台的下一代 web 开发框架<br>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。<br><a id=\"more\"></a></p>\n<h2 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><h3 id=\"架设-HTTP-服务\"><a href=\"#架设-HTTP-服务\" class=\"headerlink\" title=\"架设 HTTP 服务\"></a>架设 HTTP 服务</h3><p>只要三行代码，就可以用 Koa 架设一个 HTTP 服务。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Context-对象\"><a href=\"#Context-对象\" class=\"headerlink\" title=\"Context 对象\"></a>Context 对象</h3><p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。<br>Context.response.body属性就是发送给用户的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>main函数用来设置ctx.response.body。然后，使用app.use方法加载main函数。<br>你可能已经猜到了，ctx.response代表 HTTP Response。同样地，ctx.request代表 HTTP Request。</p>\n<h3 id=\"HTTP-Response-的类型\"><a href=\"#HTTP-Response-的类型\" class=\"headerlink\" title=\"HTTP Response 的类型\"></a>HTTP Response 的类型</h3><p>Koa 默认的返回类型是text/plain，如果想返回其他类型的内容，可以先用ctx.request.accepts判断一下，客户端希望接受什么数据（根据 HTTP Request 的Accept字段），然后使用ctx.response.type指定返回类型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.request.accepts(<span class=\"string\">'xml'</span>)) &#123;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'xml'</span>;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;data&gt;Hello World&lt;/data&gt;'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.request.accepts(<span class=\"string\">'json'</span>)) &#123;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'json'</span>;</span><br><span class=\"line\">    ctx.response.body = &#123; <span class=\"attr\">data</span>: <span class=\"string\">'Hello World'</span> &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.request.accepts(<span class=\"string\">'html'</span>)) &#123;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;p&gt;Hello World&lt;/p&gt;'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'text'</span>;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"网页模板\"><a href=\"#网页模板\" class=\"headerlink\" title=\"网页模板\"></a>网页模板</h3><p>实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">  ctx.response.body = fs.createReadStream(<span class=\"string\">'./demos/template.html'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><h3 id=\"原生路由\"><a href=\"#原生路由\" class=\"headerlink\" title=\"原生路由\"></a>原生路由</h3><p>网站一般都有多个页面。通过ctx.request.path可以获取用户请求的路径，由此实现简单的路由。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.request.path !== <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"koa-route-模块\"><a href=\"#koa-route-模块\" class=\"headerlink\" title=\"koa-route 模块\"></a>koa-route 模块</h3><p>原生路由用起来不太方便，我们可以使用封装好的koa-route模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> route = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-route'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> about = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'&lt;a href=\"/\"&gt;Index Page&lt;/a&gt;'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(<span class=\"string\">'/'</span>, main));</span><br><span class=\"line\">app.use(route.get(<span class=\"string\">'/about'</span>, about));</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态资源\"><a href=\"#静态资源\" class=\"headerlink\" title=\"静态资源\"></a>静态资源</h3><p>如果网站提供静态资源（图片、字体、样式表、脚本……），为它们一个个写路由就很麻烦，也没必要。koa-static模块封装了这部分的请求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> serve = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-static'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = serve(path.join(__dirname));</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h3><p>有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。ctx.response.redirect()方法可以发出一个302跳转，将用户导向另一个路由。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> route = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-route'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> redirect = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.redirect(<span class=\"string\">'/'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(route.get(<span class=\"string\">'/'</span>, main));</span><br><span class=\"line\">app.use(route.get(<span class=\"string\">'/redirect'</span>, redirect));</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h2><h3 id=\"Logger-功能\"><a href=\"#Logger-功能\" class=\"headerlink\" title=\"Logger 功能\"></a>Logger 功能</h3><p>Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。</p>\n<p>最简单的写法就是在main函数里面增加一行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">Date</span>.now()&#125;</span> <span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"中间件的概念\"><a href=\"#中间件的概念\" class=\"headerlink\" title=\"中间件的概念\"></a>中间件的概念</h3><p>上一个例子里面的 Logger 功能，可以拆分成一个独立函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">Date</span>.now()&#125;</span> <span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(logger);</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码中的 <strong>logger</strong> 函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。</p>\n<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的 main 也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next 函数。只要调用 next 函数，就可以把执行权转交给下一个中间件。</p>\n<h3 id=\"中间件栈\"><a href=\"#中间件栈\" class=\"headerlink\" title=\"中间件栈\"></a>中间件栈</h3><p>多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。</p>\n<ol>\n<li>最外层的中间件首先执行。</li>\n<li>调用 next 函数，把执行权交给下一个中间件。</li>\n<li>…</li>\n<li>最内层的中间件最后执行。</li>\n<li>执行结束后，把执行权交回上一层的中间件。</li>\n<li>…</li>\n<li>最外层的中间件收回执行权之后，执行 next 函数后面的代码。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> one = <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt; one'</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&lt;&lt; one'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> two = <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt; two'</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&lt;&lt; two'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> three = <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&gt;&gt; three'</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'&lt;&lt; three'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(one);</span><br><span class=\"line\">app.use(two);</span><br><span class=\"line\">app.use(three);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。作为练习，你可以将two函数里面next()这一行注释掉再执行，看看会有什么结果。</p>\n<h3 id=\"异步中间件\"><a href=\"#异步中间件\" class=\"headerlink\" title=\"异步中间件\"></a>异步中间件</h3><p>迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 async 函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs.promised'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx, next</span>) </span>&#123;</span><br><span class=\"line\">  ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">  ctx.response.body = <span class=\"keyword\">await</span> fs.readFile(<span class=\"string\">'./demos/template.html'</span>, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，fs.readFile 是一个异步操作，必须写成 await fs.readFile()，然后中间件必须写成 async 函数。</p>\n<h3 id=\"中间件的合成\"><a href=\"#中间件的合成\" class=\"headerlink\" title=\"中间件的合成\"></a>中间件的合成</h3><p>koa-compose模块可以将多个中间件合成为一个。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-compose'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">Date</span>.now()&#125;</span> <span class=\"subst\">$&#123;ctx.request.method&#125;</span> <span class=\"subst\">$&#123;ctx.request.url&#125;</span>`</span>);</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> middlewares = compose([logger, main]);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(middlewares);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><h3 id=\"500-错误\"><a href=\"#500-错误\" class=\"headerlink\" title=\"500 错误\"></a>500 错误</h3><p>如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了 ctx.throw() 方法，用来抛出错误，ctx.throw(500) 就是抛出 500 错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.throw(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"404错误\"><a href=\"#404错误\" class=\"headerlink\" title=\"404错误\"></a>404错误</h3><p>如果将ctx.response.status设置成404，就相当于ctx.throw(404)，返回404错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.response.status = <span class=\"number\">404</span>;</span><br><span class=\"line\">  ctx.response.body = <span class=\"string\">'Page Not Found'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理错误的中间件\"><a href=\"#处理错误的中间件\" class=\"headerlink\" title=\"处理错误的中间件\"></a>处理错误的中间件</h3><p>为了方便处理错误，最好使用 try…catch 将其捕获。但是，为每个中间件都写 try…catch 太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    ctx.response.status = err.statusCode || err.status || <span class=\"number\">500</span>;</span><br><span class=\"line\">    ctx.response.body = &#123;</span><br><span class=\"line\">      message: err.message</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.throw(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(handler);</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"error-事件的监听\"><a href=\"#error-事件的监听\" class=\"headerlink\" title=\"error 事件的监听\"></a>error 事件的监听</h3><p>运行过程中一旦出错，Koa 会触发一个error事件。监听这个事件，也可以处理错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.throw(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.on(<span class=\"string\">'error'</span>, (err, ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.error(<span class=\"string\">'server error'</span>, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"释放-error-事件\"><a href=\"#释放-error-事件\" class=\"headerlink\" title=\"释放 error 事件\"></a>释放 error 事件</h3><p>需要注意的是，如果错误被 try…catch 捕获，就不会触发 error 事件。这时，必须调用 ctx.app.emit()，手动释放 error 事件，才能让监听函数生效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    ctx.response.status = err.statusCode || err.status || <span class=\"number\">500</span>;</span><br><span class=\"line\">    ctx.response.type = <span class=\"string\">'html'</span>;</span><br><span class=\"line\">    ctx.response.body = <span class=\"string\">'&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;'</span>;</span><br><span class=\"line\">    ctx.app.emit(<span class=\"string\">'error'</span>, err, ctx);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"params\">ctx</span> =&gt;</span> &#123;</span><br><span class=\"line\">  ctx.throw(<span class=\"number\">500</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'logging error '</span>, err.message);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(handler);</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>上面代码中，main函数抛出错误，被handler函数捕获。catch代码块里面使用ctx.app.emit()手动释放error事件，才能让监听函数监听到。</p>\n<h2 id=\"Web-App-的功能\"><a href=\"#Web-App-的功能\" class=\"headerlink\" title=\"Web App 的功能\"></a>Web App 的功能</h2><h3 id=\"Cookies\"><a href=\"#Cookies\" class=\"headerlink\" title=\"Cookies\"></a>Cookies</h3><p>ctx.cookies用来读写 Cookie。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> n = <span class=\"built_in\">Number</span>(ctx.cookies.get(<span class=\"string\">'view'</span>) || <span class=\"number\">0</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">  ctx.cookies.set(<span class=\"string\">'view'</span>, n);</span><br><span class=\"line\">  ctx.response.body = n + <span class=\"string\">' views'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。koa-body模块可以用来从 POST 请求的数据体里面提取键值对。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> koaBody = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-body'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> body = ctx.request.body;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!body.name) ctx.throw(<span class=\"number\">400</span>, <span class=\"string\">'.name required'</span>);</span><br><span class=\"line\">  ctx.body = &#123; <span class=\"attr\">name</span>: body.name &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(koaBody());</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>打开另一个命令行窗口，运行下面的命令。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl -X POST --data <span class=\"string\">\"name=Jack\"</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;\"name\":\"Jack\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ curl -X POST --data <span class=\"string\">\"name\"</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">3000</span></span><br><span class=\"line\"><span class=\"comment\">// name required</span></span><br></pre></td></tr></table></figure>\n<p>上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>\n<h3 id=\"文件上传\"><a href=\"#文件上传\" class=\"headerlink\" title=\"文件上传\"></a>文件上传</h3><p>koa-body模块还可以用来处理文件上传。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> os = <span class=\"built_in\">require</span>(<span class=\"string\">'os'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">'koa'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> koaBody = <span class=\"built_in\">require</span>(<span class=\"string\">'koa-body'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> main = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> tmpdir = os.tmpdir();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> filePaths = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> files = ctx.request.body.files || &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> files) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> file = files[key];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> filePath = path.join(tmpdir, file.name);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> reader = fs.createReadStream(file.path);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> writer = fs.createWriteStream(filePath);</span><br><span class=\"line\">    reader.pipe(writer);</span><br><span class=\"line\">    filePaths.push(filePath);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ctx.body = filePaths;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(koaBody(&#123; <span class=\"attr\">multipart</span>: <span class=\"literal\">true</span> &#125;));</span><br><span class=\"line\">app.use(main);</span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n<p>打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，/path/to/file要更换为真实的文件路径。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl --form upload=@/path/to/file http:<span class=\"comment\">//127.0.0.1:3000</span></span><br><span class=\"line\"><span class=\"comment\">// [\"/tmp/file\"]</span></span><br></pre></td></tr></table></figure>","slug":"09-04-Koa","updated":"2018-09-04T03:40:16.089Z","comments":true,"link":"","permalink":"http://www.zosion.red/09-04-Koa/","excerpt":"# 基于 Node.js 平台的下一代 web 开发框架Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。","categories":[],"tags":[{"name":"Learning","slug":"Learning","permalink":"http://www.zosion.red/tags/Learning/"}]},{"title":"MongoDB","date":"2018-08-30T03:24:40.000Z","path":"08-30-MongoDB/","text":"# 什么是MongoDB /usr/local/Cellar/mongodb/4.0.1/bin » ./mongo MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 主要特点 MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。 Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。 MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。 Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。 Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。 Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。 GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。 MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。 MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 概念解析 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 数据库 一个mongodb中可以建立多个数据库。 MongoDB的默认数据库为”db”，该数据库存储在data目录中。 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 “show dbs” 命令可以显示所有数据的列表。执行 “db” 命令可以显示当前数据库对象或集合。运行”use”命令，可以连接到一个指定的数据库。 数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 不能是空字符串（””)。 不得含有’ ‘（空格)、.、$、/、\\和\\0 (空字符)。 应全部小写。 最多64字节。 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 文档文档是一组键值(key-value)对(即 BSON )。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。一个简单的文档例子如下： {“site”:”www.runoob.com&quot;, “name”:”菜鸟教程”} 需要注意的是： 文档中的键/值对是 有序 的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分 类型 和 大小写。 MongoDB的文档 不能有重复的键。 文档的键是 字符串。除了少数例外情况，键可以使用任意UTF-8字符。 文档键命名规范: 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。 .和$有特别的意义，只有在特定环境下才能使用。 以下划线”_”开头的键是保留的(不是严格要求的)。 集合集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。比如，我们可以将以下不同数据结构的文档插入到集合中: {“site”:”www.baidu.com&quot;}{“site”:”www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}{“site”:”www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5} 当第一个文档插入时，集合就会被创建。 合法的集合名 集合名不能是空字符串””。 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。 集合名不能以”system.”开头，这是为系统集合保留的前缀。 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。 如下实例： db.col.findOne() capped collectionsCapped collections 就是固定大小的collection。它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 “RRD” 概念类似。Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。要注意的是指定的存储大小包含了数据库的头信息。 db.createCollection(“mycoll”, {capped:true, size:100000}) 在capped collection中，你能添加新的对象。 能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。 数据库不允许进行删除。使用drop()方法删除collection所有的行。 注意: 删除之后，你必须显式的重新创建这个collection。 在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。 元数据数据库的信息是存储在集合中。它们使用了系统的命名空间： dbname.system.* 在MongoDB数据库中名字空间 dbname.system.* 是包含多种系统信息的特殊集合(Collection)，如下: 集合命名空间 描述 dbname.system.namespaces 列出所有名字空间。 dbname.system.indexes 列出所有索引。 dbname.system.profile 包含数据库概要(profile)信息。 dbname.system.users 列出所有可访问数据库的用户。 dbname.local.sources 包含复制对端（slave）的服务器信息和状态。 对于修改系统集合中的对象有如下限制。在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。是可修改的。 是可删除的。 MongoDB 数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 连接数据库启动 MongoDB 服务 只需要在 MongoDB 安装目录的 bin 目录下执行 mongodb 即可。 标准 URI 连接语法： mongodb://[username:password@]host1[:port1][,host2[:port2],…[,hostN[:portN]]][/[database][?options]] mongodb:// 这是固定的格式，必须要指定。 username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库 host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。 portX 可选的指定端口，如果不填，默认为27017 /database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。 ?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开 标准的连接格式包含了多个选项(options) 选项 描述 replicaSet=name 验证replica set的名称。 Impliesconnect=replicaSet. slaveOk=true/false true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。 safe=true/false true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。 w=n 驱动添加 { w : n } 到getLastError命令. 应用于safe=true。 wtimeoutMS=ms 驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true. fsync=true/false true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.false: 驱动不会添加到getLastError命令中。 journal=true/false 如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true connectTimeoutMS=ms 可以打开连接的时间。 socketTimeoutMS=ms 发送和接受sockets的时间。 数据库操作创建数据库如果数据库不存在，则创建数据库，否则切换到指定数据库。 use DATABASE_NAME 注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建 删除数据库删除当前数据库，默认为 test b.dropDatabase() 集合操作创建集合 db.createCollection(name, options) 参数说明： name: 要创建的集合名称 options: 可选参数, 指定有关内存大小及索引的选项 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 （可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 删除集合 db.collection.drop()返回值:如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。 文档操作文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。 插入文档MongoDB 使用 insert() 或 save() 方法向集合中插入文档 db.COLLECTION_NAME.insert(document) 查看已插入文档 db.COLLECTION_NAME.find() 插入文档你也可以使用 db.COLLECTION_NAME.save(document) 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。 3.2 版本后还有以下几种语法可用于插入文档: db.collection.insertOne():向指定集合中插入一条文档数据 db.collection.insertMany():向指定集合中插入多条文档数据 更新文档update()MongoDB 使用 update() 和 save() 方法来更新集合中的文档update() 方法用于更新已存在的文档 123456789db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明： query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 WriteConcern.NONE:没有异常抛出 WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常 WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。 WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。 WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。 WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。 WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。 实例： 1234567891011121314151617181920212223242526&gt;db.col.insert(&#123; title: 'MongoDB 教程', description: 'MongoDB 是一个 Nosql 数据库', by: '菜鸟教程', url: 'http://www.runoob.com', tags: ['mongodb', 'database', 'NoSQL'], likes: 100&#125;)// 接着我们通过 update() 方法来更新标题(title):&gt;db.col.update(&#123;'title':'MongoDB 教程'&#125;,&#123;$set:&#123;'title':'MongoDB'&#125;&#125;)WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;) # 输出信息&gt; db.col.find().pretty()&#123; \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"), \"title\" : \"MongoDB\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"菜鸟教程\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"database\", \"NoSQL\" ], \"likes\" : 100&#125; 以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。&gt;db.col.update({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}},{multi:true}) 在3.2版本开始，MongoDB提供以下更新集合文档的方法： db.collection.updateOne() 向指定集合更新单个文档 db.collection.updateMany() 向指定集合更新多个文档 save()save() 方法通过传入的文档来替换已有文档 123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明： document : 文档数据。 writeConcern :可选，抛出异常的级别。 实例 123456789101112131415161718192021222324252627// 替换 _id 为 56064f89ade2f21f36b03136 的文档数据&gt;db.col.save(&#123; \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"), \"title\" : \"MongoDB\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"Runoob\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"NoSQL\" ], \"likes\" : 110&#125;)&gt;db.col.find().pretty()&#123; \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"), \"title\" : \"MongoDB\", \"description\" : \"MongoDB 是一个 Nosql 数据库\", \"by\" : \"Runoob\", \"url\" : \"http://www.runoob.com\", \"tags\" : [ \"mongodb\", \"NoSQL\" ], \"likes\" : 110&#125; 删除文档删除集合下全部文档：db.inventory.deleteMany({})删除 status 等于 A 的全部文档：db.inventory.deleteMany({ status : &quot;A&quot; })删除 status 等于 D 的一个文档：db.inventory.deleteOne( { status: &quot;D&quot; } ) 查询文档find() 方法以非结构化的方式来显示所有文档 db.collection.find(query, projection) pretty() 方法以格式化的方式来显示所有文档。 db.collection.find().pretty() limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。 db.collection.find().limit(NUMBER) 使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。 db.collection.find().limit(NUMBER).skip(NUMBER) sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。 db.collection.find().sort({KEY:1}) 注意：skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。 若不指定 projection，则默认返回所有键，指定 projection 格式如下，有两种模式 db.collection.find(query, {title: 1, by: 1}) // inclusion模式 指定返回的键，不返回其他键db.collection.find(query, {title: 0, by: 0}) // exclusion模式 指定不返回的键,返回其他键 _id 键默认返回，需要主动指定 _id:0 才会隐藏两种模式不可混用（因为这样的话无法推断其他键是否应返回） db.collection.find(query, {title: 1, by: 0}) // 错误 只能全1或全0，除了在inclusion模式时可以指定_id为0 db.collection.find(query, {_id:0, title: 1, by: 1}) // 正确 若不想指定查询条件参数 query 可以 用 {} 代替，但是需要指定 projection 参数： querydb.collection.find({}, {title: 1}) Where 语句 操作 格式 范例 小于 {&lt;key&gt;:{$lt:&lt;value&gt;}} db.col.find({“likes”:{$lt:50}}).pretty() 小于或等于 {&lt;key&gt;:{$lte:&lt;value&gt;}} db.col.find({“likes”:{$lte:50}}).pretty() 大于 {&lt;key&gt;:{$gt:&lt;value&gt;}} db.col.find({“likes”:{$gt:50}}).pretty() 大于或等于 {&lt;key&gt;:{$gte:&lt;value&gt;}} db.col.find({“likes”:{$gte:50}}).pretty() 等于 {&lt;key&gt;:&lt;value&gt;} db.col.find({“by”:”菜鸟教程”}).pretty() 不等于 {&lt;key&gt;:{$ne:&lt;value&gt;}} db.col.find({“likes”:{$ne:50}}).pretty() AND 条件 db.col.find({key1:value1, key2:value2}).pretty() OR 条件1234567db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty() 模糊查询 db.col.find({title:/^教$/}) //使用正则匹配 索引索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构 createIndex() 方法 db.collection.createIndex(keys, options) Key 值为你要创建的索引字段，1 为指定按升序创建索引，-1 为指定按降序创建索引 createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。 db.collection.createIndex({“title”:1,”description”:-1}) options 可选参数列表如下： Parameter Type Description background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. db.collection.createIndex({open: 1, close: 1}, {background: true}) 聚合MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。 aggregate() 方法 db.collection.aggregate(AGGREGATE_OPERATION) 表达式 描述 实例 $sum 计算总和。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : &quot;$likes&quot;}}}]) $avg 计算平均值 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$avg : &quot;$likes&quot;}}}]) $min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$min : &quot;$likes&quot;}}}]) $max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$max : &quot;$likes&quot;}}}]) $push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$push: &quot;$url&quot;}}}]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$addToSet : &quot;$url&quot;}}}]) $first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, first_url : {$first : &quot;$url&quot;}}}]) $last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, last_url : {$last : &quot;$url&quot;}}}]) 管道的概念管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 复制（副本集）MongoDB复制是将数据同步在多个服务器的过程。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。复制还允许您从硬件故障和服务中断中恢复数据。 复制原理mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。mongodb各个节点常见的搭配方式为：一主一从、一主多从。主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致 副本集特征： N 个节点的集群 任何节点可作为主节点 所有写入操作都在主节点上 自动故障转移 自动恢复 副本集设置 mongod –port “PORT” –dbpath “YOUR_DB_DATA_PATH” –replSet “REPLICA_SET_INSTANCE_NAME” 副本集添加成员 rs.add(HOST_NAME:PORT) 分片在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。 为什么使用分片: 复制所有的写入操作到主节点 延迟的敏感数据会在主节点查询 单个副本集限制在12个节点 当请求量巨大时会出现内存不足。 本地磁盘不足 垂直扩展价格昂贵 备份(mongodump)与恢复(mongorestore)数据备份在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。mongodump命令可以通过参数指定导出的数据量级转存的服务器。 mongodump -h dbhost -d dbname -o dbdirectory -h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d：需要备份的数据库实例，例如：test -o：备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 mongodump 命令可选参数列表如下所示： 语法 描述 实例 mongodump –host HOST_NAME –port PORT_NUMBER 该命令将备份所有MongoDB数据 mongodump --host runoob.com --port 27017 mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY mongodump --dbpath /data/db/ --out /data/backup/ mongodump –collection COLLECTION –db DB_NAME 该命令将备份指定数据库的集合。 mongodump --collection mycol --db test 数据恢复mongodb使用 mongorestore 命令来恢复备份的数据。 mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt; –host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017 –db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ &lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。你不能同时指定 &lt;path&gt; 和 –dir 选项，–dir也可以设置备份目录。 –dir：指定备份的目录。你不能同时指定 &lt;path&gt; 和 –dir 选项。 监控在你已经安装部署并允许MongoDB服务后，你必须要了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。MongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。 mongostat 命令mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示： /usr/local/Cellar/mongodb/4.0.1/bin&gt;mongostat mongotop 命令mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示： /usr/local/Cellar/mongodb/4.0.1/bin&gt;mongotop Node.js 连接 MongoDB npm install mongodb 创建数据库N12345678var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/runoob\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; console.log(\"数据库已创建!\"); db.close();&#125;); 创建集合 createCollection()123456789101112var MongoClient = require('mongodb').MongoClient;var url = 'mongodb://localhost:27017/runoob';MongoClient.connect(url, function (err, db) &#123; if (err) throw err; console.log('数据库已创建'); var dbase = db.db(\"runoob\"); dbase.createCollection('site', function (err, res) &#123; if (err) throw err; console.log(\"创建集合!\"); db.close(); &#125;);&#125;); 数据库操作( CURD )与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据 insertOne()/insertMany()12345678910111213141516171819202122232425262728293031var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var myobj = &#123; name: \"菜鸟教程\", url: \"www.runoob\" &#125;; dbo.collection(\"site\").insertOne(myobj, function(err, res) &#123; if (err) throw err; console.log(\"文档插入成功\"); db.close(); &#125;);&#125;);ar MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var myobj = [ &#123; name: '菜鸟工具', url: 'https://c.runoob.com', type: 'cn'&#125;, &#123; name: 'Google', url: 'https://www.google.com', type: 'en'&#125;, &#123; name: 'Facebook', url: 'https://www.google.com', type: 'en'&#125; ]; dbo.collection(\"site\").insertMany(myobj, function(err, res) &#123; if (err) throw err; console.log(\"插入的文档数量为: \" + res.insertedCount); db.close(); &#125;);&#125;); 查询数据find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var whereStr = &#123;\"name\":'菜鸟教程'&#125;; // 查询条件 dbo.collection(\"site\").find(whereStr).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 更新数据 updateOne()/updateMany()1234567891011121314151617181920212223242526272829var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var whereStr = &#123;\"name\":'菜鸟教程'&#125;; // 查询条件 var updateStr = &#123;$set: &#123; \"url\" : \"https://www.runoob.com\" &#125;&#125;; dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) &#123; if (err) throw err; console.log(\"文档更新成功\"); db.close(); &#125;);&#125;);var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var whereStr = &#123;\"type\":'en'&#125;; // 查询条件 var updateStr = &#123;$set: &#123; \"url\" : \"https://www.runoob.com\" &#125;&#125;; dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) &#123; if (err) throw err; console.log(res.result.nModified + \" 条文档被更新\"); db.close(); &#125;);&#125;); 删除数据 deleteOne()/deleteMany()12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var whereStr = &#123; type: \"en\" &#125;; // 查询条件 dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) &#123; if (err) throw err; console.log(obj.result.n + \" 条文档被删除\"); db.close(); &#125;);&#125;); 排序sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); var mysort = &#123; type: 1 &#125;; dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 查询分页设置指定的返回条数可以使用 limit() 方法，该方法只接受一个参数，指定了返回的条数。如果要指定跳过的条数，可以使用 skip() 方法。 12345678910111213141516171819202122232425var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); dbo.collection(\"site\").find().limit(2).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;);var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 连接操作mongoDB 不是一个关系型数据库，但我们可以使用 $lookup 来实现左连接。例如我们有两个集合数据分别为： 集合1：orders [{ _id: 1, product_id: 154, status: 1 }] 集合2：products [{ _id: 154, name: &#39;笔记本电脑&#39; },{ _id: 155, name: &#39;耳机&#39; },{ _id: 156, name: &#39;台式电脑&#39; }] 123456789101112131415161718192021var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); dbo.collection('orders').aggregate([ &#123; $lookup: &#123; from: 'products', // 右集合 localField: 'product_id', // 左集合 join 字段 foreignField: '_id', // 右集合 join 字段 as: 'orderdetails' // 新生成字段（类型array） &#125; &#125; ]).toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;);&#125;); 删除集合drop()12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"runoob\"); // 删除 test 集合 dbo.collection(\"test\").drop(function(err, delOK) &#123; // 执行成功 delOK 返回 true，否则返回 false if (err) throw err; if (delOK) console.log(\"集合已删除\"); db.close(); &#125;);&#125;);","raw":"---\ntitle: MongoDB\ndate: 2018-08-30 11:24:40\ntags: Learning\ncomments: true\ntoc: true\n---\n#\n\n## 什么是MongoDB\n\n* /usr/local/Cellar/mongodb/4.0.1/bin » ./mongo\n\nMongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。\n在高负载的情况下，添加更多的节点，可以保证服务器性能。\nMongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB 将数据存储为一个文档，数据结构由键值(key=>value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。\n<!-- more -->\n\n### 主要特点\n\n* MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。\n* 你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=\"Sameer\",Address=\"8 Gandhi Road\")来实现更快的排序。\n* 你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。\n* 如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。\n* Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。\n* MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。\n* Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。\n* Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。\n* Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。\n* GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。\n* MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。\n* MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。\n\n### 概念解析\n\n|SQL术语/概念|MongoDB术语/概念|解释/说明|\n|:-|:-|:-|\n|database|database|数据库|\n|table|collection|数据库表/集合|\n|row|document|数据记录行/文档|\n|column|field|数据字段/域|\n|index|index|索引|\n|table joins||表连接,MongoDB不支持|\n|primary key|primary key|主键,MongoDB自动将_id字段设置为主键|\n\n### 数据库\n\n* 一个mongodb中可以建立多个数据库。\n* MongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\n* MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n\n> \"show dbs\" 命令可以显示所有数据的列表。\n> 执行 \"db\" 命令可以显示当前数据库对象或集合。\n> 运行\"use\"命令，可以连接到一个指定的数据库。\n\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n\n* 不能是空字符串（\"\")。\n* 不得含有' '（空格)、.、$、/、\\和\\0 (空字符)。\n* 应全部小写。\n* 最多64字节。\n\n有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。\n\n* admin： 从权限的角度来看，这是\"root\"数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。\n* local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合\n* config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。\n\n### 文档\n\n**文档**是一组键值(**key-value**)对(即 **BSON** )。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n一个简单的文档例子如下：\n> {\"site\":\"www.runoob.com\", \"name\":\"菜鸟教程\"}\n\n需要注意的是：\n\n1. 文档中的键/值对是 **有序** 的。\n2. 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。\n3. MongoDB区分 **类型** 和 **大小写**。\n4. MongoDB的文档 **不能有重复的键**。\n5. 文档的键是 **字符串**。除了少数例外情况，键可以使用任意UTF-8字符。\n\n文档键命名规范:\n\n* 键不能含有\\0 (空字符)。这个字符用来表示键的结尾。\n* .和$有特别的意义，只有在特定环境下才能使用。\n* 以下划线\"_\"开头的键是保留的(不是严格要求的)。\n\n### 集合\n\n**集合**就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。\n集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n比如，我们可以将以下不同数据结构的文档插入到集合中:\n> {\"site\":\"www.baidu.com\"}\n> {\"site\":\"www.google.com\",\"name\":\"Google\"}\n> {\"site\":\"www.runoob.com\",\"name\":\"菜鸟教程\",\"num\":5}\n\n当第一个文档插入时，集合就会被创建。\n\n#### 合法的集合名\n\n* 集合名不能是空字符串\"\"。\n* 集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。\n* 集合名不能以\"system.\"开头，这是为系统集合保留的前缀。\n* 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。\n\n如下实例：\n> db.col.findOne()\n\n#### capped collections\n\nCapped collections 就是固定大小的collection。\n它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 \"RRD\" 概念类似。\nCapped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。\n要注意的是指定的存储大小包含了数据库的头信息。\n> db.createCollection(\"mycoll\", {capped:true, size:100000})\n\n* 在capped collection中，你能添加新的对象。\n* 能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。\n* 数据库不允许进行删除。使用drop()方法删除collection所有的行。\n* 注意: 删除之后，你必须显式的重新创建这个collection。\n* 在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。\n\n### 元数据\n\n数据库的信息是存储在集合中。它们使用了系统的命名空间：\n> dbname.system.*\n\n在MongoDB数据库中名字空间 dbname.system.* 是包含多种系统信息的特殊集合(Collection)，如下:\n\n|集合命名空间|描述|\n|:-|:-|\n|dbname.system.namespaces|列出所有名字空间。|\n|dbname.system.indexes|列出所有索引。|\n|dbname.system.profile|包含数据库概要(profile)信息。|\n|dbname.system.users|列出所有可访问数据库的用户。|\n|dbname.local.sources|包含复制对端（slave）的服务器信息和状态。|\n\n对于修改系统集合中的对象有如下限制。\n在{{system.indexes}}插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。\n{{system.users}}是可修改的。 {{system.profile}}是可删除的。\n\n### MongoDB 数据类型\n\n|数据类型|描述|\n|:-|:-|\n|String|字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。|\n|Integer|整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。|\n|Boolean|布尔值。用于存储布尔值（真/假）。|\n|Double|双精度浮点值。用于存储浮点值。|\n|Min/Max keys|将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。|\n|Array|用于将数组或列表或多个值存储为一个键。|\n|Timestamp|时间戳。记录文档修改或添加的具体时间。|\n|Object|用于内嵌文档。|\n|Null|用于创建空值。|\n|Symbol|符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。|\n|Date|日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建Date 对象，传入年月日信息。|\n|Object ID|对象 ID。用于创建文档的 ID。|\n|Binary Data|二进制数据。用于存储二进制数据。|\n|Code|代码类型。用于在文档中存储 JavaScript 代码。|\n|Regular expression|正则表达式类型。用于存储正则表达式。|\n\n## 连接数据库\n\n启动 MongoDB 服务\n> 只需要在 MongoDB 安装目录的 bin 目录下执行 mongodb 即可。\n\n标准 URI 连接语法：\n> mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]\n\n* mongodb:// 这是固定的格式，必须要指定。\n* username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库\n* host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。\n* portX 可选的指定端口，如果不填，默认为27017\n* /database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。\n* ?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&或;（分号）隔开\n\n标准的连接格式包含了多个选项(options)\n\n|选项|描述|\n|:-|:-|\n|replicaSet=name|验证replica set的名称。 Impliesconnect=replicaSet.|\n|slaveOk=true/false|true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。|\n|safe=true/false|true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。|\n|w=n|驱动添加 { w : n } 到getLastError命令. 应用于safe=true。|\n|wtimeoutMS=ms|驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true.|\n|fsync=true/false|true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.false: 驱动不会添加到getLastError命令中。|\n|journal=true/false|如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true|\n|connectTimeoutMS=ms|可以打开连接的时间。|\n|socketTimeoutMS=ms|发送和接受sockets的时间。|\n\n## 数据库操作\n\n### 创建数据库\n\n如果数据库不存在，则创建数据库，否则切换到指定数据库。\n> use DATABASE_NAME\n  >> 注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建\n\n### 删除数据库\n\n删除当前数据库，默认为 test\n> b.dropDatabase()\n\n## 集合操作\n\n### 创建集合\n\n> db.createCollection(name, options)\n\n参数说明：\n\n* name: 要创建的集合名称\n* options: 可选参数, 指定有关内存大小及索引的选项\n\n|字段|类型|描述|\n|:-|:-|:-|\n|capped|布尔|（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。**当该值为 true 时，必须指定 size 参数。**|\n|autoIndexId|布尔|（可选）如为 true，自动在 _id 字段创建索引。默认为 false。|\n|size|数值|可选）为固定集合指定一个最大值（以字节计）。**如果 capped 为 true，也需要指定该字段。**|\n|max|数值|（可选）指定固定集合中包含文档的最大数量。|\n\n### 删除集合\n\n> db.collection.drop()\n**返回值:**如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。\n\n## 文档操作\n\n文档的数据结构和JSON基本一样。\n所有存储在集合中的数据都是BSON格式。\nBSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。\n\n### 插入文档\n\nMongoDB 使用 insert() 或 save() 方法向集合中插入文档\n> db.COLLECTION_NAME.insert(document)\n\n查看已插入文档\n> db.COLLECTION_NAME.find()\n\n插入文档你也可以使用 **db.COLLECTION_NAME.save(document)** 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。\n\n3.2 版本后还有以下几种语法可用于插入文档:\n\n* db.collection.insertOne():向指定集合中插入一条文档数据\n* db.collection.insertMany():向指定集合中插入多条文档数据\n\n### 更新文档\n\n#### update()\n\nMongoDB 使用 **update()** 和 **save()** 方法来更新集合中的文档\nupdate() 方法用于更新已存在的文档\n\n```javascript\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n* **query** : update的查询条件，类似sql update查询内where后面的。\n* **update** : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n* **upsert** : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n* **multi** : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n* **writeConcern** :可选，抛出异常的级别。\n  * WriteConcern.NONE:没有异常抛出\n  * WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常\n  * WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。\n  * WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。\n  * WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。\n  * WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。\n  * WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。\n\n实例：\n\n```javascript\n>db.col.insert({\n  title: 'MongoDB 教程',\n  description: 'MongoDB 是一个 Nosql 数据库',\n  by: '菜鸟教程',\n  url: 'http://www.runoob.com',\n  tags: ['mongodb', 'database', 'NoSQL'],\n  likes: 100\n})\n\n// 接着我们通过 update() 方法来更新标题(title):\n>db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}})\nWriteResult({ \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 })   # 输出信息\n> db.col.find().pretty()\n{\n  \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\n  \"title\" : \"MongoDB\",\n  \"description\" : \"MongoDB 是一个 Nosql 数据库\",\n  \"by\" : \"菜鸟教程\",\n  \"url\" : \"http://www.runoob.com\",\n  \"tags\" : [\n          \"mongodb\",\n          \"database\",\n          \"NoSQL\"\n  ],\n  \"likes\" : 100\n}\n```\n\n以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。\n`>db.col.update({'title':'MongoDB 教程'},{$set:{'title':'MongoDB'}},{multi:true})`\n\n在3.2版本开始，MongoDB提供以下更新集合文档的方法：\n\n* db.collection.updateOne() 向指定集合更新单个文档\n* db.collection.updateMany() 向指定集合更新多个文档\n\n#### save()\n\nsave() 方法通过传入的文档来替换已有文档\n\n```javascript\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n参数说明：\n\n* **document** : 文档数据。\n* **writeConcern** :可选，抛出异常的级别。\n\n实例\n\n```javascript\n// 替换 _id 为 56064f89ade2f21f36b03136 的文档数据\n>db.col.save({\n  \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\n  \"title\" : \"MongoDB\",\n  \"description\" : \"MongoDB 是一个 Nosql 数据库\",\n  \"by\" : \"Runoob\",\n  \"url\" : \"http://www.runoob.com\",\n  \"tags\" : [\n          \"mongodb\",\n          \"NoSQL\"\n  ],\n  \"likes\" : 110\n})\n\n>db.col.find().pretty()\n{\n  \"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\n  \"title\" : \"MongoDB\",\n  \"description\" : \"MongoDB 是一个 Nosql 数据库\",\n  \"by\" : \"Runoob\",\n  \"url\" : \"http://www.runoob.com\",\n  \"tags\" : [\n          \"mongodb\",\n          \"NoSQL\"\n  ],\n  \"likes\" : 110\n}\n```\n\n### 删除文档\n\n删除集合下全部文档：\n`db.inventory.deleteMany({})`\n删除 status 等于 A 的全部文档：\n`db.inventory.deleteMany({ status : \"A\" })`\n删除 status 等于 D 的一个文档：\n`db.inventory.deleteOne( { status: \"D\" } )`\n\n### 查询文档\n\nfind() 方法以非结构化的方式来显示所有文档\n> db.collection.find(query, projection)\n\npretty() 方法以格式化的方式来显示所有文档。\n> db.collection.find().pretty()\n\nlimit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。\n> db.collection.find().limit(NUMBER)\n\n使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。\n> db.collection.find().limit(NUMBER).skip(NUMBER)\n\nsort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。\n> db.collection.find().sort({KEY:1})\n\n注意：**skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。**\n\n* query ：可选，使用查询操作符指定查询条件\n* projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。\n\n若不指定 projection，则默认返回所有键，指定 projection 格式如下，有两种模式\n> db.collection.find(query, {title: 1, by: 1}) // inclusion模式 指定返回的键，不返回其他键\n> db.collection.find(query, {title: 0, by: 0}) // exclusion模式 指定不返回的键,返回其他键\n\n_id 键默认返回，需要主动指定 _id:0 才会隐藏\n两种模式不可混用（因为这样的话无法推断其他键是否应返回）\n> db.collection.find(query, {title: 1, by: 0}) // 错误\n\n只能全1或全0，除了在inclusion模式时可以指定_id为0\n>db.collection.find(query, {_id:0, title: 1, by: 1}) // 正确\n\n若不想指定查询条件参数 query 可以 用 {} 代替，但是需要指定 projection 参数：\n> querydb.collection.find({}, {title: 1})\n\n#### Where 语句\n\n|操作|格式|范例|\n|:-|:-|:-|\n|小于|`{<key>:{$lt:<value>}}`|db.col.find({\"likes\":{$lt:50}}).pretty()|\n|小于或等于|`{<key>:{$lte:<value>}}`|db.col.find({\"likes\":{$lte:50}}).pretty()|\n|大于|`{<key>:{$gt:<value>}}`|db.col.find({\"likes\":{$gt:50}}).pretty()|\n|大于或等于|`{<key>:{$gte:<value>}}`|db.col.find({\"likes\":{$gte:50}}).pretty()|\n|等于|`{<key>:<value>}`|db.col.find({\"by\":\"菜鸟教程\"}).pretty()|\n|不等于|`{<key>:{$ne:<value>}}`|db.col.find({\"likes\":{$ne:50}}).pretty()|\n\n#### AND 条件\n\n> db.col.find({key1:value1, key2:value2}).pretty()\n\n#### OR 条件\n\n```javascript\ndb.col.find(\n   {\n      $or: [\n         {key1: value1}, {key2:value2}\n      ]\n   }\n).pretty()\n```\n\n#### 模糊查询\n\n> db.col.find({title:/^教$/}) //使用正则匹配\n\n## 索引\n\n索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构\n\n### createIndex() 方法\n\n> db.collection.createIndex(keys, options)\n\n* Key 值为你要创建的索引字段，1 为指定按升序创建索引，-1 为指定按降序创建索引\n\ncreateIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。\n> db.collection.createIndex({\"title\":1,\"description\":-1})\n\noptions 可选参数列表如下：\n\n|Parameter|Type|Description|\n|:-|:-|:-|\n|background|Boolean|建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 \"background\" 可选参数。 \"background\" 默认值为false。|\n|unique|Boolean|建立的索引是否唯一。指定为true创建唯一索引。默认值为false.|\n|name|string|索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。|\n|sparse|Boolean|对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.|\n|expireAfterSeconds|integer|指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。|\n|v|index version|索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。|\n|weights|document|索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。|\n|default_language|string|对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语|\n|language_override|string|对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.|\n\n> db.collection.createIndex({open: 1, close: 1}, {background: true})\n\n## 聚合\n\nMongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。\n\n### aggregate() 方法\n\n> db.collection.aggregate(AGGREGATE_OPERATION)\n\n|表达式|描述|实例|\n|:-|:-|:-|\n|$sum|计算总和。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$sum : \"$likes\"}}}])`|\n|$avg|计算平均值|`db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$avg : \"$likes\"}}}])`|\n|$min|获取集合中所有文档对应值得最小值。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$min : \"$likes\"}}}])`|\n|$max|获取集合中所有文档对应值得最大值。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", num_tutorial : {$max : \"$likes\"}}}])`|\n|$push|在结果文档中插入值到一个数组中。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$push: \"$url\"}}}])`|\n|$addToSet|在结果文档中插入值到一个数组中，但不创建副本。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", url : {$addToSet : \"$url\"}}}])`|\n|$first|根据资源文档的排序获取第一个文档数据。|`db.mycol.aggregate([{$group : {_id : \"$by_user\", first_url : {$first : \"$url\"}}}])`|\n|$last|根据资源文档的排序获取最后一个文档数据|`db.mycol.aggregate([{$group : {_id : \"$by_user\", last_url : {$last : \"$url\"}}}])`|\n\n### 管道的概念\n\n管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。\nMongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。\n表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。\n这里我们介绍一下聚合框架中常用的几个操作：\n\n* $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。\n* $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。\n* $limit：用来限制MongoDB聚合管道返回的文档数。\n* $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。\n* $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。\n* $group：将集合中的文档分组，可用于统计结果。\n* $sort：将输入文档排序后输出。\n* $geoNear：输出接近某一地理位置的有序文档。\n\n## 复制（副本集）\n\nMongoDB复制是将数据同步在多个服务器的过程。\n复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。\n复制还允许您从硬件故障和服务中断中恢复数据。\n\n### 复制原理\n\nmongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。\nmongodb各个节点常见的搭配方式为：一主一从、一主多从。\n主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致\n\n#### 副本集特征：\n\n* N 个节点的集群\n* 任何节点可作为主节点\n* 所有写入操作都在主节点上\n* 自动故障转移\n* 自动恢复\n\n### 副本集设置\n\n> mongod --port \"PORT\" --dbpath \"YOUR_DB_DATA_PATH\" --replSet \"REPLICA_SET_INSTANCE_NAME\"\n\n### 副本集添加成员\n\n> rs.add(HOST_NAME:PORT)\n\n## 分片\n\n在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。\n当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。\n\n为什么使用分片:\n\n* 复制所有的写入操作到主节点\n* 延迟的敏感数据会在主节点查询\n* 单个副本集限制在12个节点\n* 当请求量巨大时会出现内存不足。\n* 本地磁盘不足\n* 垂直扩展价格昂贵\n\n## 备份(mongodump)与恢复(mongorestore)\n\n### 数据备份\n\n在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。\nmongodump命令可以通过参数指定导出的数据量级转存的服务器。\n\n> mongodump -h dbhost -d dbname -o dbdirectory\n\n* -h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017\n* -d：需要备份的数据库实例，例如：test\n* -o：备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。\n\nmongodump 命令可选参数列表如下所示：\n\n|语法|描述|实例|\n|:-|:-|:-|\n|mongodump --host HOST_NAME --port PORT_NUMBER|该命令将备份所有MongoDB数据|`mongodump --host runoob.com --port 27017`|\n|mongodump --dbpath DB_PATH --out BACKUP_DIRECTORY||`mongodump --dbpath /data/db/ --out /data/backup/`|\n|mongodump --collection COLLECTION --db DB_NAME|该命令将备份指定数据库的集合。|`mongodump --collection mycol --db test`|\n\n### 数据恢复\n\nmongodb使用 mongorestore 命令来恢复备份的数据。\n> mongorestore -h `<hostname><:port>` -d dbname `<path>`\n\n* --host <:port>, -h <:port>：MongoDB所在服务器地址，默认为： localhost:27017\n* --db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2\n* --drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！\n* `<path>`：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。你不能同时指定 `<path>` 和 --dir 选项，--dir也可以设置备份目录。\n* --dir：指定备份的目录。你不能同时指定 `<path>` 和 --dir 选项。\n\n## 监控\n\n在你已经安装部署并允许MongoDB服务后，你必须要了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。\nMongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。\n\n### mongostat 命令\n\nmongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。\n启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：\n> /usr/local/Cellar/mongodb/4.0.1/bin>mongostat\n\n### mongotop 命令\n\nmongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。\n启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示：\n> /usr/local/Cellar/mongodb/4.0.1/bin>mongotop\n\n## Node.js 连接 MongoDB\n\n> npm install mongodb\n\n### 创建数据库N\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/runoob\";\n\nMongoClient.connect(url, function(err, db) {\n  if (err) throw err;\n  console.log(\"数据库已创建!\");\n  db.close();\n});\n```\n\n### 创建集合 createCollection()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = 'mongodb://localhost:27017/runoob';\nMongoClient.connect(url, function (err, db) {\n    if (err) throw err;\n    console.log('数据库已创建');\n    var dbase = db.db(\"runoob\");\n    dbase.createCollection('site', function (err, res) {\n        if (err) throw err;\n        console.log(\"创建集合!\");\n        db.close();\n    });\n});\n```\n\n### 数据库操作( CURD )\n\n与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。\n\n#### 插入数据 insertOne()/insertMany()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj = { name: \"菜鸟教程\", url: \"www.runoob\" };\n    dbo.collection(\"site\").insertOne(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档插入成功\");\n        db.close();\n    });\n});\n\nar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var myobj =  [\n        { name: '菜鸟工具', url: 'https://c.runoob.com', type: 'cn'},\n        { name: 'Google', url: 'https://www.google.com', type: 'en'},\n        { name: 'Facebook', url: 'https://www.google.com', type: 'en'}\n       ];\n    dbo.collection(\"site\").insertMany(myobj, function(err, res) {\n        if (err) throw err;\n        console.log(\"插入的文档数量为: \" + res.insertedCount);\n        db.close();\n    });\n});\n```\n\n#### 查询数据\n\nfind() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n     var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    dbo.collection(\"site\").find(whereStr).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n#### 更新数据 updateOne()/updateMany()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"name\":'菜鸟教程'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateOne(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n        console.log(\"文档更新成功\");\n        db.close();\n    });\n});\n\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = {\"type\":'en'};  // 查询条件\n    var updateStr = {$set: { \"url\" : \"https://www.runoob.com\" }};\n    dbo.collection(\"site\").updateMany(whereStr, updateStr, function(err, res) {\n        if (err) throw err;\n         console.log(res.result.nModified + \" 条文档被更新\");\n        db.close();\n    });\n});\n```\n\n#### 删除数据 deleteOne()/deleteMany()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var whereStr = { type: \"en\" };  // 查询条件\n    dbo.collection(\"site\").deleteMany(whereStr, function(err, obj) {\n        if (err) throw err;\n        console.log(obj.result.n + \" 条文档被删除\");\n        db.close();\n    });\n});\n```\n\n#### 排序\n\nsort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    var mysort = { type: 1 };\n    dbo.collection(\"site\").find().sort(mysort).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n    });\n});\n```\n\n#### 查询分页\n\n设置指定的返回条数可以使用 limit() 方法，该方法只接受一个参数，指定了返回的条数。\n如果要指定跳过的条数，可以使用 skip() 方法。\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    dbo.collection(\"site\").find().skip(2).limit(2).toArray(function(err, result) {\n        if (err) throw err;\n        console.log(result);\n        db.close();\n  });\n});\n```\n\n#### 连接操作\n\nmongoDB 不是一个关系型数据库，但我们可以使用 **$lookup** 来实现左连接。\n例如我们有两个集合数据分别为：\n\n集合1：orders\n> `[{ _id: 1, product_id: 154, status: 1 }]`\n\n集合2：products\n> `[{ _id: 154, name: '笔记本电脑' },{ _id: 155, name: '耳机' },{ _id: 156, name: '台式电脑' }]`\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://127.0.0.1:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n  if (err) throw err;\n  var dbo = db.db(\"runoob\");\n  dbo.collection('orders').aggregate([\n    { $lookup:\n       {\n         from: 'products',            // 右集合\n         localField: 'product_id',    // 左集合 join 字段\n         foreignField: '_id',         // 右集合 join 字段\n         as: 'orderdetails'           // 新生成字段（类型array）\n       }\n     }\n    ]).toArray(function(err, res) {\n    if (err) throw err;\n    console.log(JSON.stringify(res));\n    db.close();\n  });\n});\n```\n\n#### 删除集合drop()\n\n```javascript\nvar MongoClient = require('mongodb').MongoClient;\nvar url = \"mongodb://localhost:27017/\";\n\nMongoClient.connect(url, function(err, db) {\n    if (err) throw err;\n    var dbo = db.db(\"runoob\");\n    // 删除 test 集合\n    dbo.collection(\"test\").drop(function(err, delOK) {  // 执行成功 delOK 返回 true，否则返回 false\n        if (err) throw err;\n        if (delOK) console.log(\"集合已删除\");\n        db.close();\n    });\n});\n```","content":"<p>#</p>\n<h2 id=\"什么是MongoDB\"><a href=\"#什么是MongoDB\" class=\"headerlink\" title=\"什么是MongoDB\"></a>什么是MongoDB</h2><ul>\n<li>/usr/local/Cellar/mongodb/4.0.1/bin » ./mongo</li>\n</ul>\n<p>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<br>在高负载的情况下，添加更多的节点，可以保证服务器性能。<br>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。<br><a id=\"more\"></a></p>\n<h3 id=\"主要特点\"><a href=\"#主要特点\" class=\"headerlink\" title=\"主要特点\"></a>主要特点</h3><ul>\n<li>MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。</li>\n<li>你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=”Sameer”,Address=”8 Gandhi Road”)来实现更快的排序。</li>\n<li>你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。</li>\n<li>如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。</li>\n<li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。</li>\n<li>MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。</li>\n<li>Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。</li>\n<li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。</li>\n<li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。</li>\n<li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。</li>\n<li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。</li>\n<li>MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</li>\n</ul>\n<h3 id=\"概念解析\"><a href=\"#概念解析\" class=\"headerlink\" title=\"概念解析\"></a>概念解析</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">SQL术语/概念</th>\n<th style=\"text-align:left\">MongoDB术语/概念</th>\n<th style=\"text-align:left\">解释/说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">database</td>\n<td style=\"text-align:left\">database</td>\n<td style=\"text-align:left\">数据库</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">table</td>\n<td style=\"text-align:left\">collection</td>\n<td style=\"text-align:left\">数据库表/集合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">row</td>\n<td style=\"text-align:left\">document</td>\n<td style=\"text-align:left\">数据记录行/文档</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">column</td>\n<td style=\"text-align:left\">field</td>\n<td style=\"text-align:left\">数据字段/域</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">index</td>\n<td style=\"text-align:left\">index</td>\n<td style=\"text-align:left\">索引</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">table joins</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">表连接,MongoDB不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">primary key</td>\n<td style=\"text-align:left\">primary key</td>\n<td style=\"text-align:left\">主键,MongoDB自动将_id字段设置为主键</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><ul>\n<li>一个mongodb中可以建立多个数据库。</li>\n<li>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</li>\n<li>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</li>\n</ul>\n<blockquote>\n<p>“show dbs” 命令可以显示所有数据的列表。<br>执行 “db” 命令可以显示当前数据库对象或集合。<br>运行”use”命令，可以连接到一个指定的数据库。</p>\n</blockquote>\n<p>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。</p>\n<ul>\n<li>不能是空字符串（””)。</li>\n<li>不得含有’ ‘（空格)、.、$、/、\\和\\0 (空字符)。</li>\n<li>应全部小写。</li>\n<li>最多64字节。</li>\n</ul>\n<p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>\n<ul>\n<li>admin： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li>\n<li>local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li>\n<li>config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><p><strong>文档</strong>是一组键值(<strong>key-value</strong>)对(即 <strong>BSON</strong> )。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。<br>一个简单的文档例子如下：</p>\n<blockquote>\n<p>{“site”:”<a href=\"http://www.runoob.com&quot;\" target=\"_blank\" rel=\"noopener\">www.runoob.com&quot;</a>, “name”:”菜鸟教程”}</p>\n</blockquote>\n<p>需要注意的是：</p>\n<ol>\n<li>文档中的键/值对是 <strong>有序</strong> 的。</li>\n<li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li>\n<li>MongoDB区分 <strong>类型</strong> 和 <strong>大小写</strong>。</li>\n<li>MongoDB的文档 <strong>不能有重复的键</strong>。</li>\n<li>文档的键是 <strong>字符串</strong>。除了少数例外情况，键可以使用任意UTF-8字符。</li>\n</ol>\n<p>文档键命名规范:</p>\n<ul>\n<li>键不能含有\\0 (空字符)。这个字符用来表示键的结尾。</li>\n<li>.和$有特别的意义，只有在特定环境下才能使用。</li>\n<li>以下划线”_”开头的键是保留的(不是严格要求的)。</li>\n</ul>\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p><strong>集合</strong>就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。<br>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。<br>比如，我们可以将以下不同数据结构的文档插入到集合中:</p>\n<blockquote>\n<p>{“site”:”<a href=\"http://www.baidu.com&quot;}\" target=\"_blank\" rel=\"noopener\">www.baidu.com&quot;}</a><br>{“site”:”<a href=\"http://www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}\" target=\"_blank\" rel=\"noopener\">www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}</a><br>{“site”:”<a href=\"http://www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5}\" target=\"_blank\" rel=\"noopener\">www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5}</a></p>\n</blockquote>\n<p>当第一个文档插入时，集合就会被创建。</p>\n<h4 id=\"合法的集合名\"><a href=\"#合法的集合名\" class=\"headerlink\" title=\"合法的集合名\"></a>合法的集合名</h4><ul>\n<li>集合名不能是空字符串””。</li>\n<li>集合名不能含有\\0字符（空字符)，这个字符表示集合名的结尾。</li>\n<li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li>\n<li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li>\n</ul>\n<p>如下实例：</p>\n<blockquote>\n<p>db.col.findOne()</p>\n</blockquote>\n<h4 id=\"capped-collections\"><a href=\"#capped-collections\" class=\"headerlink\" title=\"capped collections\"></a>capped collections</h4><p>Capped collections 就是固定大小的collection。<br>它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 “RRD” 概念类似。<br>Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。<br>要注意的是指定的存储大小包含了数据库的头信息。</p>\n<blockquote>\n<p>db.createCollection(“mycoll”, {capped:true, size:100000})</p>\n</blockquote>\n<ul>\n<li>在capped collection中，你能添加新的对象。</li>\n<li>能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</li>\n<li>数据库不允许进行删除。使用drop()方法删除collection所有的行。</li>\n<li>注意: 删除之后，你必须显式的重新创建这个collection。</li>\n<li>在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</li>\n</ul>\n<h3 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h3><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：</p>\n<blockquote>\n<p>dbname.system.*</p>\n</blockquote>\n<p>在MongoDB数据库中名字空间 dbname.system.* 是包含多种系统信息的特殊集合(Collection)，如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">集合命名空间</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">dbname.system.namespaces</td>\n<td style=\"text-align:left\">列出所有名字空间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dbname.system.indexes</td>\n<td style=\"text-align:left\">列出所有索引。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dbname.system.profile</td>\n<td style=\"text-align:left\">包含数据库概要(profile)信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dbname.system.users</td>\n<td style=\"text-align:left\">列出所有可访问数据库的用户。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">dbname.local.sources</td>\n<td style=\"text-align:left\">包含复制对端（slave）的服务器信息和状态。</td>\n</tr>\n</tbody>\n</table>\n<p>对于修改系统集合中的对象有如下限制。<br>在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。<br>是可修改的。 是可删除的。</p>\n<h3 id=\"MongoDB-数据类型\"><a href=\"#MongoDB-数据类型\" class=\"headerlink\" title=\"MongoDB 数据类型\"></a>MongoDB 数据类型</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">String</td>\n<td style=\"text-align:left\">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Integer</td>\n<td style=\"text-align:left\">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Boolean</td>\n<td style=\"text-align:left\">布尔值。用于存储布尔值（真/假）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Double</td>\n<td style=\"text-align:left\">双精度浮点值。用于存储浮点值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Min/Max keys</td>\n<td style=\"text-align:left\">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Array</td>\n<td style=\"text-align:left\">用于将数组或列表或多个值存储为一个键。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Timestamp</td>\n<td style=\"text-align:left\">时间戳。记录文档修改或添加的具体时间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Object</td>\n<td style=\"text-align:left\">用于内嵌文档。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Null</td>\n<td style=\"text-align:left\">用于创建空值。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Symbol</td>\n<td style=\"text-align:left\">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Date</td>\n<td style=\"text-align:left\">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建Date 对象，传入年月日信息。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Object ID</td>\n<td style=\"text-align:left\">对象 ID。用于创建文档的 ID。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Binary Data</td>\n<td style=\"text-align:left\">二进制数据。用于存储二进制数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Code</td>\n<td style=\"text-align:left\">代码类型。用于在文档中存储 JavaScript 代码。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Regular expression</td>\n<td style=\"text-align:left\">正则表达式类型。用于存储正则表达式。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h2><p>启动 MongoDB 服务</p>\n<blockquote>\n<p>只需要在 MongoDB 安装目录的 bin 目录下执行 mongodb 即可。</p>\n</blockquote>\n<p>标准 URI 连接语法：</p>\n<blockquote>\n<p>mongodb://[username:password@]host1[:port1][,host2[:port2],…[,hostN[:portN]]][/[database][?options]]</p>\n</blockquote>\n<ul>\n<li>mongodb:// 这是固定的格式，必须要指定。</li>\n<li>username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库</li>\n<li>host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li>\n<li>portX 可选的指定端口，如果不填，默认为27017</li>\n<li>/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。</li>\n<li>?options 是连接选项。如果不使用/database，则前面需要加上/。所有连接选项都是键值对name=value，键值对之间通过&amp;或;（分号）隔开</li>\n</ul>\n<p>标准的连接格式包含了多个选项(options)</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">选项</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">replicaSet=name</td>\n<td style=\"text-align:left\">验证replica set的名称。 Impliesconnect=replicaSet.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">slaveOk=true/false</td>\n<td style=\"text-align:left\">true:在connect=direct模式下，驱动会连接第一台机器，即使这台服务器不是主。在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。false: 在 connect=direct模式下，驱动会自动找寻主服务器. 在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">safe=true/false</td>\n<td style=\"text-align:left\">true: 在执行更新操作之后，驱动都会发送getLastError命令来确保更新成功。(还要参考 wtimeoutMS).false: 在每次更新之后，驱动不会发送getLastError来确保更新成功。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">w=n</td>\n<td style=\"text-align:left\">驱动添加 { w : n } 到getLastError命令. 应用于safe=true。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">wtimeoutMS=ms</td>\n<td style=\"text-align:left\">驱动添加 { wtimeout : ms } 到 getlasterror 命令. 应用于 safe=true.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">fsync=true/false</td>\n<td style=\"text-align:left\">true: 驱动添加 { fsync : true } 到 getlasterror 命令.应用于 safe=true.false: 驱动不会添加到getLastError命令中。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">journal=true/false</td>\n<td style=\"text-align:left\">如果设置为 true, 同步到 journal (在提交到数据库前写入到实体中). 应用于 safe=true</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">connectTimeoutMS=ms</td>\n<td style=\"text-align:left\">可以打开连接的时间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">socketTimeoutMS=ms</td>\n<td style=\"text-align:left\">发送和接受sockets的时间。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><p>如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>\n<blockquote>\n<p>use DATABASE_NAME</p>\n<blockquote>\n<p>注意: 在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建</p>\n</blockquote>\n</blockquote>\n<h3 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h3><p>删除当前数据库，默认为 test</p>\n<blockquote>\n<p>b.dropDatabase()</p>\n</blockquote>\n<h2 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h2><h3 id=\"创建集合\"><a href=\"#创建集合\" class=\"headerlink\" title=\"创建集合\"></a>创建集合</h3><blockquote>\n<p>db.createCollection(name, options)</p>\n</blockquote>\n<p>参数说明：</p>\n<ul>\n<li>name: 要创建的集合名称</li>\n<li>options: 可选参数, 指定有关内存大小及索引的选项</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">capped</td>\n<td style=\"text-align:left\">布尔</td>\n<td style=\"text-align:left\">（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。<strong>当该值为 true 时，必须指定 size 参数。</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">autoIndexId</td>\n<td style=\"text-align:left\">布尔</td>\n<td style=\"text-align:left\">（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">size</td>\n<td style=\"text-align:left\">数值</td>\n<td style=\"text-align:left\">可选）为固定集合指定一个最大值（以字节计）。<strong>如果 capped 为 true，也需要指定该字段。</strong></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">max</td>\n<td style=\"text-align:left\">数值</td>\n<td style=\"text-align:left\">（可选）指定固定集合中包含文档的最大数量。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"删除集合\"><a href=\"#删除集合\" class=\"headerlink\" title=\"删除集合\"></a>删除集合</h3><blockquote>\n<p>db.collection.drop()<br><strong>返回值:</strong>如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。</p>\n</blockquote>\n<h2 id=\"文档操作\"><a href=\"#文档操作\" class=\"headerlink\" title=\"文档操作\"></a>文档操作</h2><p>文档的数据结构和JSON基本一样。<br>所有存储在集合中的数据都是BSON格式。<br>BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。</p>\n<h3 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h3><p>MongoDB 使用 insert() 或 save() 方法向集合中插入文档</p>\n<blockquote>\n<p>db.COLLECTION_NAME.insert(document)</p>\n</blockquote>\n<p>查看已插入文档</p>\n<blockquote>\n<p>db.COLLECTION_NAME.find()</p>\n</blockquote>\n<p>插入文档你也可以使用 <strong>db.COLLECTION_NAME.save(document)</strong> 命令。如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。</p>\n<p>3.2 版本后还有以下几种语法可用于插入文档:</p>\n<ul>\n<li>db.collection.insertOne():向指定集合中插入一条文档数据</li>\n<li>db.collection.insertMany():向指定集合中插入多条文档数据</li>\n</ul>\n<h3 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h3><h4 id=\"update\"><a href=\"#update\" class=\"headerlink\" title=\"update()\"></a>update()</h4><p>MongoDB 使用 <strong>update()</strong> 和 <strong>save()</strong> 方法来更新集合中的文档<br>update() 方法用于更新已存在的文档</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.update(</span><br><span class=\"line\">   &lt;query&gt;,</span><br><span class=\"line\">   &lt;update&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     upsert: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">boolean</span>&gt;</span>,</span></span><br><span class=\"line\">     multi: &lt;boolean&gt;,</span><br><span class=\"line\">     writeConcern: &lt;document&gt;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><strong>query</strong> : update的查询条件，类似sql update查询内where后面的。</li>\n<li><strong>update</strong> : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li>\n<li><strong>upsert</strong> : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li>\n<li><strong>multi</strong> : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li>\n<li><strong>writeConcern</strong> :可选，抛出异常的级别。<ul>\n<li>WriteConcern.NONE:没有异常抛出</li>\n<li>WriteConcern.NORMAL:仅抛出网络错误异常，没有服务器错误异常</li>\n<li>WriteConcern.SAFE:抛出网络错误异常、服务器错误异常；并等待服务器完成写操作。</li>\n<li>WriteConcern.MAJORITY: 抛出网络错误异常、服务器错误异常；并等待一个主服务器完成写操作。</li>\n<li>WriteConcern.FSYNC_SAFE: 抛出网络错误异常、服务器错误异常；写操作等待服务器将数据刷新到磁盘。</li>\n<li>WriteConcern.JOURNAL_SAFE:抛出网络错误异常、服务器错误异常；写操作等待服务器提交到磁盘的日志文件。</li>\n<li>WriteConcern.REPLICAS_SAFE:抛出网络错误异常、服务器错误异常；等待至少2台服务器完成写操作。</li>\n</ul>\n</li>\n</ul>\n<p>实例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;db.col.insert(&#123;</span><br><span class=\"line\">  title: <span class=\"string\">'MongoDB 教程'</span>,</span><br><span class=\"line\">  description: <span class=\"string\">'MongoDB 是一个 Nosql 数据库'</span>,</span><br><span class=\"line\">  by: <span class=\"string\">'菜鸟教程'</span>,</span><br><span class=\"line\">  url: <span class=\"string\">'http://www.runoob.com'</span>,</span><br><span class=\"line\">  tags: [<span class=\"string\">'mongodb'</span>, <span class=\"string\">'database'</span>, <span class=\"string\">'NoSQL'</span>],</span><br><span class=\"line\">  likes: <span class=\"number\">100</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接着我们通过 update() 方法来更新标题(title):</span></span><br><span class=\"line\">&gt;db.col.update(&#123;<span class=\"string\">'title'</span>:<span class=\"string\">'MongoDB 教程'</span>&#125;,&#123;<span class=\"attr\">$set</span>:&#123;<span class=\"string\">'title'</span>:<span class=\"string\">'MongoDB'</span>&#125;&#125;)</span><br><span class=\"line\">WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)   # 输出信息</span><br><span class=\"line\">&gt; db.col.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56064f89ade2f21f36b03136\"</span>),</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"MongoDB\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"by\"</span> : <span class=\"string\">\"菜鸟教程\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"tags\"</span> : [</span><br><span class=\"line\">          <span class=\"string\">\"mongodb\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"database\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"NoSQL\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"likes\"</span> : <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。<br><code>&gt;db.col.update({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}},{multi:true})</code></p>\n<p>在3.2版本开始，MongoDB提供以下更新集合文档的方法：</p>\n<ul>\n<li>db.collection.updateOne() 向指定集合更新单个文档</li>\n<li>db.collection.updateMany() 向指定集合更新多个文档</li>\n</ul>\n<h4 id=\"save\"><a href=\"#save\" class=\"headerlink\" title=\"save()\"></a>save()</h4><p>save() 方法通过传入的文档来替换已有文档</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.save(</span><br><span class=\"line\">   &lt;<span class=\"built_in\">document</span>&gt;,</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     writeConcern: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">document</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   &#125;</span></span><br><span class=\"line\"><span class=\"xml\">)</span></span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li><strong>document</strong> : 文档数据。</li>\n<li><strong>writeConcern</strong> :可选，抛出异常的级别。</li>\n</ul>\n<p>实例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 替换 _id 为 56064f89ade2f21f36b03136 的文档数据</span></span><br><span class=\"line\">&gt;db.col.save(&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56064f89ade2f21f36b03136\"</span>),</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"MongoDB\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"by\"</span> : <span class=\"string\">\"Runoob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"tags\"</span> : [</span><br><span class=\"line\">          <span class=\"string\">\"mongodb\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"NoSQL\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"likes\"</span> : <span class=\"number\">110</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;db.col.find().pretty()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"56064f89ade2f21f36b03136\"</span>),</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span> : <span class=\"string\">\"MongoDB\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"description\"</span> : <span class=\"string\">\"MongoDB 是一个 Nosql 数据库\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"by\"</span> : <span class=\"string\">\"Runoob\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"url\"</span> : <span class=\"string\">\"http://www.runoob.com\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"tags\"</span> : [</span><br><span class=\"line\">          <span class=\"string\">\"mongodb\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"NoSQL\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"string\">\"likes\"</span> : <span class=\"number\">110</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除文档\"><a href=\"#删除文档\" class=\"headerlink\" title=\"删除文档\"></a>删除文档</h3><p>删除集合下全部文档：<br><code>db.inventory.deleteMany({})</code><br>删除 status 等于 A 的全部文档：<br><code>db.inventory.deleteMany({ status : &quot;A&quot; })</code><br>删除 status 等于 D 的一个文档：<br><code>db.inventory.deleteOne( { status: &quot;D&quot; } )</code></p>\n<h3 id=\"查询文档\"><a href=\"#查询文档\" class=\"headerlink\" title=\"查询文档\"></a>查询文档</h3><p>find() 方法以非结构化的方式来显示所有文档</p>\n<blockquote>\n<p>db.collection.find(query, projection)</p>\n</blockquote>\n<p>pretty() 方法以格式化的方式来显示所有文档。</p>\n<blockquote>\n<p>db.collection.find().pretty()</p>\n</blockquote>\n<p>limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。</p>\n<blockquote>\n<p>db.collection.find().limit(NUMBER)</p>\n</blockquote>\n<p>使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。</p>\n<blockquote>\n<p>db.collection.find().limit(NUMBER).skip(NUMBER)</p>\n</blockquote>\n<p>sort() 方法对数据进行排序，sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。</p>\n<blockquote>\n<p>db.collection.find().sort({KEY:1})</p>\n</blockquote>\n<p>注意：<strong>skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。</strong></p>\n<ul>\n<li>query ：可选，使用查询操作符指定查询条件</li>\n<li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li>\n</ul>\n<p>若不指定 projection，则默认返回所有键，指定 projection 格式如下，有两种模式</p>\n<blockquote>\n<p>db.collection.find(query, {title: 1, by: 1}) // inclusion模式 指定返回的键，不返回其他键<br>db.collection.find(query, {title: 0, by: 0}) // exclusion模式 指定不返回的键,返回其他键</p>\n</blockquote>\n<p>_id 键默认返回，需要主动指定 _id:0 才会隐藏<br>两种模式不可混用（因为这样的话无法推断其他键是否应返回）</p>\n<blockquote>\n<p>db.collection.find(query, {title: 1, by: 0}) // 错误</p>\n</blockquote>\n<p>只能全1或全0，除了在inclusion模式时可以指定_id为0</p>\n<blockquote>\n<p>db.collection.find(query, {_id:0, title: 1, by: 1}) // 正确</p>\n</blockquote>\n<p>若不想指定查询条件参数 query 可以 用 {} 代替，但是需要指定 projection 参数：</p>\n<blockquote>\n<p>querydb.collection.find({}, {title: 1})</p>\n</blockquote>\n<h4 id=\"Where-语句\"><a href=\"#Where-语句\" class=\"headerlink\" title=\"Where 语句\"></a>Where 语句</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">操作</th>\n<th style=\"text-align:left\">格式</th>\n<th style=\"text-align:left\">范例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">小于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td>\n<td style=\"text-align:left\">db.col.find({“likes”:{$lt:50}}).pretty()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">小于或等于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td>\n<td style=\"text-align:left\">db.col.find({“likes”:{$lte:50}}).pretty()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td>\n<td style=\"text-align:left\">db.col.find({“likes”:{$gt:50}}).pretty()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于或等于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td>\n<td style=\"text-align:left\">db.col.find({“likes”:{$gte:50}}).pretty()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">等于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:&lt;value&gt;}</code></td>\n<td style=\"text-align:left\">db.col.find({“by”:”菜鸟教程”}).pretty()</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不等于</td>\n<td style=\"text-align:left\"><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td>\n<td style=\"text-align:left\">db.col.find({“likes”:{$ne:50}}).pretty()</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"AND-条件\"><a href=\"#AND-条件\" class=\"headerlink\" title=\"AND 条件\"></a>AND 条件</h4><blockquote>\n<p>db.col.find({key1:value1, key2:value2}).pretty()</p>\n</blockquote>\n<h4 id=\"OR-条件\"><a href=\"#OR-条件\" class=\"headerlink\" title=\"OR 条件\"></a>OR 条件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      $or: [</span><br><span class=\"line\">         &#123;<span class=\"attr\">key1</span>: value1&#125;, &#123;<span class=\"attr\">key2</span>:value2&#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">).pretty()</span><br></pre></td></tr></table></figure>\n<h4 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h4><blockquote>\n<p>db.col.find({title:/^教$/}) //使用正则匹配</p>\n</blockquote>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p>\n<h3 id=\"createIndex-方法\"><a href=\"#createIndex-方法\" class=\"headerlink\" title=\"createIndex() 方法\"></a>createIndex() 方法</h3><blockquote>\n<p>db.collection.createIndex(keys, options)</p>\n</blockquote>\n<ul>\n<li>Key 值为你要创建的索引字段，1 为指定按升序创建索引，-1 为指定按降序创建索引</li>\n</ul>\n<p>createIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。</p>\n<blockquote>\n<p>db.collection.createIndex({“title”:1,”description”:-1})</p>\n</blockquote>\n<p>options 可选参数列表如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Parameter</th>\n<th style=\"text-align:left\">Type</th>\n<th style=\"text-align:left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">background</td>\n<td style=\"text-align:left\">Boolean</td>\n<td style=\"text-align:left\">建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">unique</td>\n<td style=\"text-align:left\">Boolean</td>\n<td style=\"text-align:left\">建立的索引是否唯一。指定为true创建唯一索引。默认值为false.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">name</td>\n<td style=\"text-align:left\">string</td>\n<td style=\"text-align:left\">索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">sparse</td>\n<td style=\"text-align:left\">Boolean</td>\n<td style=\"text-align:left\">对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">expireAfterSeconds</td>\n<td style=\"text-align:left\">integer</td>\n<td style=\"text-align:left\">指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">v</td>\n<td style=\"text-align:left\">index version</td>\n<td style=\"text-align:left\">索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">weights</td>\n<td style=\"text-align:left\">document</td>\n<td style=\"text-align:left\">索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">default_language</td>\n<td style=\"text-align:left\">string</td>\n<td style=\"text-align:left\">对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">language_override</td>\n<td style=\"text-align:left\">string</td>\n<td style=\"text-align:left\">对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>db.collection.createIndex({open: 1, close: 1}, {background: true})</p>\n</blockquote>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>MongoDB中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果。有点类似sql语句中的 count(*)。</p>\n<h3 id=\"aggregate-方法\"><a href=\"#aggregate-方法\" class=\"headerlink\" title=\"aggregate() 方法\"></a>aggregate() 方法</h3><blockquote>\n<p>db.collection.aggregate(AGGREGATE_OPERATION)</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">表达式</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">$sum</td>\n<td style=\"text-align:left\">计算总和。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : &quot;$likes&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$avg</td>\n<td style=\"text-align:left\">计算平均值</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$avg : &quot;$likes&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$min</td>\n<td style=\"text-align:left\">获取集合中所有文档对应值得最小值。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$min : &quot;$likes&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$max</td>\n<td style=\"text-align:left\">获取集合中所有文档对应值得最大值。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$max : &quot;$likes&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$push</td>\n<td style=\"text-align:left\">在结果文档中插入值到一个数组中。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$push: &quot;$url&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$addToSet</td>\n<td style=\"text-align:left\">在结果文档中插入值到一个数组中，但不创建副本。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, url : {$addToSet : &quot;$url&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$first</td>\n<td style=\"text-align:left\">根据资源文档的排序获取第一个文档数据。</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, first_url : {$first : &quot;$url&quot;}}}])</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$last</td>\n<td style=\"text-align:left\">根据资源文档的排序获取最后一个文档数据</td>\n<td style=\"text-align:left\"><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, last_url : {$last : &quot;$url&quot;}}}])</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"管道的概念\"><a href=\"#管道的概念\" class=\"headerlink\" title=\"管道的概念\"></a>管道的概念</h3><p>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。<br>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。<br>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。<br>这里我们介绍一下聚合框架中常用的几个操作：</p>\n<ul>\n<li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li>\n<li>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</li>\n<li>$limit：用来限制MongoDB聚合管道返回的文档数。</li>\n<li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li>\n<li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li>\n<li>$group：将集合中的文档分组，可用于统计结果。</li>\n<li>$sort：将输入文档排序后输出。</li>\n<li>$geoNear：输出接近某一地理位置的有序文档。</li>\n</ul>\n<h2 id=\"复制（副本集）\"><a href=\"#复制（副本集）\" class=\"headerlink\" title=\"复制（副本集）\"></a>复制（副本集）</h2><p>MongoDB复制是将数据同步在多个服务器的过程。<br>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。<br>复制还允许您从硬件故障和服务中断中恢复数据。</p>\n<h3 id=\"复制原理\"><a href=\"#复制原理\" class=\"headerlink\" title=\"复制原理\"></a>复制原理</h3><p>mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。<br>mongodb各个节点常见的搭配方式为：一主一从、一主多从。<br>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致</p>\n<h4 id=\"副本集特征：\"><a href=\"#副本集特征：\" class=\"headerlink\" title=\"副本集特征：\"></a>副本集特征：</h4><ul>\n<li>N 个节点的集群</li>\n<li>任何节点可作为主节点</li>\n<li>所有写入操作都在主节点上</li>\n<li>自动故障转移</li>\n<li>自动恢复</li>\n</ul>\n<h3 id=\"副本集设置\"><a href=\"#副本集设置\" class=\"headerlink\" title=\"副本集设置\"></a>副本集设置</h3><blockquote>\n<p>mongod –port “PORT” –dbpath “YOUR_DB_DATA_PATH” –replSet “REPLICA_SET_INSTANCE_NAME”</p>\n</blockquote>\n<h3 id=\"副本集添加成员\"><a href=\"#副本集添加成员\" class=\"headerlink\" title=\"副本集添加成员\"></a>副本集添加成员</h3><blockquote>\n<p>rs.add(HOST_NAME:PORT)</p>\n</blockquote>\n<h2 id=\"分片\"><a href=\"#分片\" class=\"headerlink\" title=\"分片\"></a>分片</h2><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。<br>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。</p>\n<p>为什么使用分片:</p>\n<ul>\n<li>复制所有的写入操作到主节点</li>\n<li>延迟的敏感数据会在主节点查询</li>\n<li>单个副本集限制在12个节点</li>\n<li>当请求量巨大时会出现内存不足。</li>\n<li>本地磁盘不足</li>\n<li>垂直扩展价格昂贵</li>\n</ul>\n<h2 id=\"备份-mongodump-与恢复-mongorestore\"><a href=\"#备份-mongodump-与恢复-mongorestore\" class=\"headerlink\" title=\"备份(mongodump)与恢复(mongorestore)\"></a>备份(mongodump)与恢复(mongorestore)</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>在Mongodb中我们使用mongodump命令来备份MongoDB数据。该命令可以导出所有数据到指定目录中。<br>mongodump命令可以通过参数指定导出的数据量级转存的服务器。</p>\n<blockquote>\n<p>mongodump -h dbhost -d dbname -o dbdirectory</p>\n</blockquote>\n<ul>\n<li>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</li>\n<li>-d：需要备份的数据库实例，例如：test</li>\n<li>-o：备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。</li>\n</ul>\n<p>mongodump 命令可选参数列表如下所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">语法</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">实例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">mongodump –host HOST_NAME –port PORT_NUMBER</td>\n<td style=\"text-align:left\">该命令将备份所有MongoDB数据</td>\n<td style=\"text-align:left\"><code>mongodump --host runoob.com --port 27017</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mongodump –dbpath DB_PATH –out BACKUP_DIRECTORY</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"><code>mongodump --dbpath /data/db/ --out /data/backup/</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">mongodump –collection COLLECTION –db DB_NAME</td>\n<td style=\"text-align:left\">该命令将备份指定数据库的集合。</td>\n<td style=\"text-align:left\"><code>mongodump --collection mycol --db test</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数据恢复\"><a href=\"#数据恢复\" class=\"headerlink\" title=\"数据恢复\"></a>数据恢复</h3><p>mongodb使用 mongorestore 命令来恢复备份的数据。</p>\n<blockquote>\n<p>mongorestore -h <code>&lt;hostname&gt;&lt;:port&gt;</code> -d dbname <code>&lt;path&gt;</code></p>\n</blockquote>\n<ul>\n<li>–host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017</li>\n<li>–db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</li>\n<li>–drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</li>\n<li><code>&lt;path&gt;</code>：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。你不能同时指定 <code>&lt;path&gt;</code> 和 –dir 选项，–dir也可以设置备份目录。</li>\n<li>–dir：指定备份的目录。你不能同时指定 <code>&lt;path&gt;</code> 和 –dir 选项。</li>\n</ul>\n<h2 id=\"监控\"><a href=\"#监控\" class=\"headerlink\" title=\"监控\"></a>监控</h2><p>在你已经安装部署并允许MongoDB服务后，你必须要了解MongoDB的运行情况，并查看MongoDB的性能。这样在大流量得情况下可以很好的应对并保证MongoDB正常运作。<br>MongoDB中提供了mongostat 和 mongotop 两个命令来监控MongoDB的运行情况。</p>\n<h3 id=\"mongostat-命令\"><a href=\"#mongostat-命令\" class=\"headerlink\" title=\"mongostat 命令\"></a>mongostat 命令</h3><p>mongostat是mongodb自带的状态检测工具，在命令行下使用。它会间隔固定时间获取mongodb的当前运行状态，并输出。如果你发现数据库突然变慢或者有其他问题的话，你第一手的操作就考虑采用mongostat来查看mongo的状态。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongostat命令，如下所示：</p>\n<blockquote>\n<p>/usr/local/Cellar/mongodb/4.0.1/bin&gt;mongostat</p>\n</blockquote>\n<h3 id=\"mongotop-命令\"><a href=\"#mongotop-命令\" class=\"headerlink\" title=\"mongotop 命令\"></a>mongotop 命令</h3><p>mongotop也是mongodb下的一个内置工具，mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。<br>启动你的Mongod服务，进入到你安装的MongoDB目录下的bin目录， 然后输入mongotop命令，如下所示：</p>\n<blockquote>\n<p>/usr/local/Cellar/mongodb/4.0.1/bin&gt;mongotop</p>\n</blockquote>\n<h2 id=\"Node-js-连接-MongoDB\"><a href=\"#Node-js-连接-MongoDB\" class=\"headerlink\" title=\"Node.js 连接 MongoDB\"></a>Node.js 连接 MongoDB</h2><blockquote>\n<p>npm install mongodb</p>\n</blockquote>\n<h3 id=\"创建数据库N\"><a href=\"#创建数据库N\" class=\"headerlink\" title=\"创建数据库N\"></a>创建数据库N</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/runoob\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"数据库已创建!\"</span>);</span><br><span class=\"line\">  db.close();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建集合-createCollection\"><a href=\"#创建集合-createCollection\" class=\"headerlink\" title=\"创建集合 createCollection()\"></a>创建集合 createCollection()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'mongodb://localhost:27017/runoob'</span>;</span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'数据库已创建'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbase = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbase.createCollection(<span class=\"string\">'site'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"创建集合!\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"数据库操作-CURD\"><a href=\"#数据库操作-CURD\" class=\"headerlink\" title=\"数据库操作( CURD )\"></a>数据库操作( CURD )</h3><p>与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。</p>\n<h4 id=\"插入数据-insertOne-insertMany\"><a href=\"#插入数据-insertOne-insertMany\" class=\"headerlink\" title=\"插入数据 insertOne()/insertMany()\"></a>插入数据 insertOne()/insertMany()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">\"菜鸟教程\"</span>, <span class=\"attr\">url</span>: <span class=\"string\">\"www.runoob\"</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertOne(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档插入成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ar MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> myobj =  [</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'菜鸟工具'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://c.runoob.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'cn'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Google'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Facebook'</span>, <span class=\"attr\">url</span>: <span class=\"string\">'https://www.google.com'</span>, <span class=\"attr\">type</span>: <span class=\"string\">'en'</span>&#125;</span><br><span class=\"line\">       ];</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).insertMany(myobj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"插入的文档数量为: \"</span> + res.insertedCount);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h4><p>find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find(whereStr).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新数据-updateOne-updateMany\"><a href=\"#更新数据-updateOne-updateMany\" class=\"headerlink\" title=\"更新数据 updateOne()/updateMany()\"></a>更新数据 updateOne()/updateMany()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">'菜鸟教程'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateOne(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"文档更新成功\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123;<span class=\"string\">\"type\"</span>:<span class=\"string\">'en'</span>&#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> updateStr = &#123;<span class=\"attr\">$set</span>: &#123; <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://www.runoob.com\"</span> &#125;&#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).updateMany(whereStr, updateStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">         <span class=\"built_in\">console</span>.log(res.result.nModified + <span class=\"string\">\" 条文档被更新\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除数据-deleteOne-deleteMany\"><a href=\"#删除数据-deleteOne-deleteMany\" class=\"headerlink\" title=\"删除数据 deleteOne()/deleteMany()\"></a>删除数据 deleteOne()/deleteMany()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> whereStr = &#123; <span class=\"attr\">type</span>: <span class=\"string\">\"en\"</span> &#125;;  <span class=\"comment\">// 查询条件</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).deleteMany(whereStr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, obj</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(obj.result.n + <span class=\"string\">\" 条文档被删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><p>sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mysort = &#123; <span class=\"attr\">type</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().sort(mysort).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询分页\"><a href=\"#查询分页\" class=\"headerlink\" title=\"查询分页\"></a>查询分页</h4><p>设置指定的返回条数可以使用 limit() 方法，该方法只接受一个参数，指定了返回的条数。<br>如果要指定跳过的条数，可以使用 skip() 方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"site\"</span>).find().skip(<span class=\"number\">2</span>).limit(<span class=\"number\">2</span>).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接操作\"><a href=\"#连接操作\" class=\"headerlink\" title=\"连接操作\"></a>连接操作</h4><p>mongoDB 不是一个关系型数据库，但我们可以使用 <strong>$lookup</strong> 来实现左连接。<br>例如我们有两个集合数据分别为：</p>\n<p>集合1：orders</p>\n<blockquote>\n<p><code>[{ _id: 1, product_id: 154, status: 1 }]</code></p>\n</blockquote>\n<p>集合2：products</p>\n<blockquote>\n<p><code>[{ _id: 154, name: &#39;笔记本电脑&#39; },{ _id: 155, name: &#39;耳机&#39; },{ _id: 156, name: &#39;台式电脑&#39; }]</code></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://127.0.0.1:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">  dbo.collection(<span class=\"string\">'orders'</span>).aggregate([</span><br><span class=\"line\">    &#123; <span class=\"attr\">$lookup</span>:</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         <span class=\"keyword\">from</span>: <span class=\"string\">'products'</span>,            <span class=\"comment\">// 右集合</span></span><br><span class=\"line\">         localField: <span class=\"string\">'product_id'</span>,    <span class=\"comment\">// 左集合 join 字段</span></span><br><span class=\"line\">         foreignField: <span class=\"string\">'_id'</span>,         <span class=\"comment\">// 右集合 join 字段</span></span><br><span class=\"line\">         <span class=\"keyword\">as</span>: <span class=\"string\">'orderdetails'</span>           <span class=\"comment\">// 新生成字段（类型array）</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">    ]).toArray(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(res));</span><br><span class=\"line\">    db.close();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除集合drop\"><a href=\"#删除集合drop\" class=\"headerlink\" title=\"删除集合drop()\"></a>删除集合drop()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MongoClient = <span class=\"built_in\">require</span>(<span class=\"string\">'mongodb'</span>).MongoClient;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"mongodb://localhost:27017/\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MongoClient.connect(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, db</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dbo = db.db(<span class=\"string\">\"runoob\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 删除 test 集合</span></span><br><span class=\"line\">    dbo.collection(<span class=\"string\">\"test\"</span>).drop(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, delOK</span>) </span>&#123;  <span class=\"comment\">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delOK) <span class=\"built_in\">console</span>.log(<span class=\"string\">\"集合已删除\"</span>);</span><br><span class=\"line\">        db.close();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","slug":"08-30-MongoDB","updated":"2018-09-03T09:22:28.051Z","comments":true,"link":"","permalink":"http://www.zosion.red/08-30-MongoDB/","excerpt":"# 什么是MongoDB /usr/local/Cellar/mongodb/4.0.1/bin » ./mongo MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负载的情况下，添加更多的节点，可以保证服务器性能。MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。","categories":[],"tags":[{"name":"Learning","slug":"Learning","permalink":"http://www.zosion.red/tags/Learning/"}]},{"title":"山口百惠","date":"2018-07-16T07:13:20.000Z","path":"07-16-山口百惠/","text":"偶然听到《风再起时》的原版《さよならの向う侧》(再见的另一方)，于是中了百惠的毒，拉了她所有的歌单，一遍又一遍洗耳","raw":"---\ntitle: 山口百惠\ndate: 2018-07-16 15:13:20\ntags: Essays\n---\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=669138&auto=0&height=66\"></iframe>\n\n偶然听到《风再起时》的原版《さよならの向う侧》(再见的另一方)，于是中了百惠的毒，拉了她所有的歌单，一遍又一遍洗耳","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=669138&auto=0&height=66\"></iframe>\n\n<p>偶然听到《风再起时》的原版《さよならの向う侧》(再见的另一方)，于是中了百惠的毒，拉了她所有的歌单，一遍又一遍洗耳</p>\n","slug":"07-16-山口百惠","updated":"2018-07-17T09:24:43.999Z","comments":true,"link":"","permalink":"http://www.zosion.red/07-16-山口百惠/","excerpt":"","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://www.zosion.red/tags/Essays/"}]},{"title":"微习惯养成计划","date":"2018-07-09T02:38:28.000Z","path":"07-09-微习惯养成计划/","text":"「以下每日必执行之！睡前检查执行情况！2018-07-09」 1 写点东西 2 看点东西 =&gt; 于是就有长进了 3 炼点东西","raw":"---\ntitle: 微习惯养成计划\ndate: 2018-07-09 10:38:28\ntags: Daily\nprivate: true\ncomments: false\n---\n「以下每日必执行之！睡前检查执行情况！2018-07-09」\n\n- 1 写点东西\n- 2 看点东西  =>  **于是就有长进了**\n- 3 炼点东西\n","content":"<p>「以下每日必执行之！睡前检查执行情况！2018-07-09」</p>\n<ul>\n<li>1 写点东西</li>\n<li>2 看点东西  =&gt;  <strong>于是就有长进了</strong></li>\n<li>3 炼点东西</li>\n</ul>\n","slug":"07-09-微习惯养成计划","updated":"2018-07-16T07:29:14.340Z","comments":false,"link":"","permalink":"http://www.zosion.red/07-09-微习惯养成计划/","excerpt":"","categories":[],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://www.zosion.red/tags/Daily/"}]},{"title":"日三省","date":"2018-07-06T02:14:05.000Z","path":"07-06-日三省/","text":"看书了吗？ 锻炼了吗？ 记录了吗?","raw":"---\ntitle: 日三省\ndate: 2018-07-06 10:14:05\ntags: Daily\nprivate: true\ncomments: false\n---\n- [ ] 看书了吗？\n- [ ] 锻炼了吗？\n- [ ] 记录了吗?","content":"<ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 看书了吗？</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 锻炼了吗？</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 记录了吗?</li>\n</ul>\n","slug":"07-06-日三省","updated":"2018-07-09T06:55:10.170Z","comments":false,"link":"","permalink":"http://www.zosion.red/07-06-日三省/","excerpt":"","categories":[],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://www.zosion.red/tags/Daily/"}]},{"title":"微变","date":"2018-07-02T02:36:32.000Z","path":"07-02-微变/","text":"每天多读点书，多做一点锻炼。一行字、一个俯卧撑都可以，千万不要不做。","raw":"---\ntitle: 微变\ndate: 2018-07-02 10:36:32\ntags: Daily\ncomments: false\nprivate: true\n---\n{% img /assets/images/scense/1.jpg 2000 %}\n每天多读点书，多做一点锻炼。一行字、一个俯卧撑都可以，千万不要不做。","content":"<img src=\"/assets/images/scense/1.jpg\" width=\"2000\">\n<p>每天多读点书，多做一点锻炼。一行字、一个俯卧撑都可以，千万不要不做。</p>\n","slug":"07-02-微变","updated":"2018-07-09T06:22:13.713Z","comments":false,"link":"","permalink":"http://www.zosion.red/07-02-微变/","excerpt":"","categories":[],"tags":[{"name":"Daily","slug":"Daily","permalink":"http://www.zosion.red/tags/Daily/"}]},{"title":"Markdown 常用语法","date":"2018-06-29T05:45:37.000Z","path":"06-29-Markdown 常用语法/","text":"# 快捷键 快捷键 功能 Ctrl + B Toggle bold Ctrl + I Toggle italic Alt + S Toggle strikethrough Ctrl + Shift + ] Toggle heading (uplevel) Ctrl + Shift + [ Toggle heading (downlevel) Alt + C Check/Uncheck task list item 标题# h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 分级标题一级标题 ====================== 二级标题 --------------------- 引用&gt; hello world! &gt; hello world! hello world! hello world! &gt; aaaaaaaaa &gt;&gt; bbbbbbbbb &gt;&gt;&gt; cccccccccc 行内标记标记之外`hello world`标记之外 代码块12345&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 注：与上行距离一空行注：根据不同的语言配置不同的代码着色 插入链接[百度1](http://www.baidu.com/ &quot;百度一下&quot;) [百度2][2] [2]: http://www.baidu.com/ 插入图片![](/assets/images/avatar.jpg &apos;dome&apos;) ![name][01] [01]: /assets/images/avatar.jpg &apos;dome&apos; 插入图片带有链接[![](/assets/images/avatar.jpg &apos;百度&apos;)](http://www.baidu.com) [![](/assets/images/avatar.jpg &apos;百度&apos;)][5] [5]: http://www.baidu.com 视频插入&lt;iframe height=498 width=510 src=&apos;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&apos; frameborder=0 &apos;allowfullscreen&apos;&gt;&lt;/iframe&gt; 表格| a | b | c | |:-------:|:------------- | ----------:| | 居中 | 左对齐 | 右对齐 | |=========|===============|============| 序表1. one 2. two 3. three * one * two * ww * three - four + five 任务列表- [ ] last - [x] first 脚注Markdown[^1] [^1]: Markdown是一种纯文本标记语言 分隔符*** --- * * *","raw":"---\ntitle: Markdown 常用语法\ndate: 2018-06-29 13:45:37\ntags: Learning\nreward: true\ntoc: true\ncomments: true\n---\n#\n\n## 快捷键\n\n| 快捷键              |  功能                         |\n|:-------------------|:-----------------------------|\n| Ctrl + B           |  Toggle bold                 |\n| Ctrl + I           |  Toggle italic               |\n| Alt + S            |  Toggle strikethrough        |\n| Ctrl + Shift + ]   |  Toggle heading (uplevel)    |\n| Ctrl + Shift + [   |  Toggle heading (downlevel)  |\n| Alt + C            |  Check/Uncheck task list item|\n<!-- more -->\n\n## 标题\n\n    # h1\n    ## h2\n    ### h3\n    #### h4\n    ##### h5\n    ###### h6\n\n## 分级标题\n\n    一级标题\n    ======================\n    二级标题\n    ---------------------\n\n## 引用\n\n    > hello world!\n\n    > hello world!\n      hello world!\n      hello world!\n\n    > aaaaaaaaa\n    >> bbbbbbbbb\n    >>> cccccccccc  \n\n## 行内标记\n\n    标记之外`hello world`标记之外\n\n## 代码块\n\n```html\n  <div>\n      <div></div>\n      <div></div>\n      <div></div>\n  </div>\n```\n\n注：与上行距离一空行\n注：根据不同的语言配置不同的代码着色\n\n## 插入链接\n\n    [百度1](http://www.baidu.com/ \"百度一下\")\n\n    [百度2][2]\n\n      [2]: http://www.baidu.com/\n\n## 插入图片\n\n    ![](/assets/images/avatar.jpg 'dome')\n\n    ![name][01]\n\n      [01]: /assets/images/avatar.jpg 'dome'\n\n## 插入图片带有链接\n\n    [![](/assets/images/avatar.jpg '百度')](http://www.baidu.com)\n\n    [![](/assets/images/avatar.jpg '百度')][5]\n\n      [5]: http://www.baidu.com\n\n## 视频插入\n\n    <iframe height=498 width=510 src='http://player.youku.com/embed/XMjgzNzM0NTYxNg==' frameborder=0 'allowfullscreen'></iframe>\n\n## 表格\n\n    |    a    |       b       |      c     |\n    |:-------:|:------------- | ----------:|\n    |   居中  |     左对齐    |   右对齐   |\n    |=========|===============|============|\n\n## 序表\n\n    1. one\n    2. two\n    3. three\n\n    * one\n    * two\n      * ww\n    * three\n    - four\n    + five\n\n## 任务列表\n\n    - [ ] last\n    - [x] first\n\n## 脚注\n\n    Markdown[^1]\n\n      [^1]: Markdown是一种纯文本标记语言\n\n## 分隔符\n\n    ***\n    ---\n    * * *","content":"<p>#</p>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">快捷键</th>\n<th style=\"text-align:left\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Ctrl + B</td>\n<td style=\"text-align:left\">Toggle bold</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ctrl + I</td>\n<td style=\"text-align:left\">Toggle italic</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Alt + S</td>\n<td style=\"text-align:left\">Toggle strikethrough</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ctrl + Shift + ]</td>\n<td style=\"text-align:left\">Toggle heading (uplevel)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ctrl + Shift + [</td>\n<td style=\"text-align:left\">Toggle heading (downlevel)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Alt + C</td>\n<td style=\"text-align:left\">Check/Uncheck task list item</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><pre><code># h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n</code></pre><h2 id=\"分级标题\"><a href=\"#分级标题\" class=\"headerlink\" title=\"分级标题\"></a>分级标题</h2><pre><code>一级标题\n======================\n二级标题\n---------------------\n</code></pre><h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><pre><code>&gt; hello world!\n\n&gt; hello world!\n  hello world!\n  hello world!\n\n&gt; aaaaaaaaa\n&gt;&gt; bbbbbbbbb\n&gt;&gt;&gt; cccccccccc  \n</code></pre><h2 id=\"行内标记\"><a href=\"#行内标记\" class=\"headerlink\" title=\"行内标记\"></a>行内标记</h2><pre><code>标记之外`hello world`标记之外\n</code></pre><h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>注：与上行距离一空行<br>注：根据不同的语言配置不同的代码着色</p>\n<h2 id=\"插入链接\"><a href=\"#插入链接\" class=\"headerlink\" title=\"插入链接\"></a>插入链接</h2><pre><code>[百度1](http://www.baidu.com/ &quot;百度一下&quot;)\n\n[百度2][2]\n\n  [2]: http://www.baidu.com/\n</code></pre><h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><pre><code>![](/assets/images/avatar.jpg &apos;dome&apos;)\n\n![name][01]\n\n  [01]: /assets/images/avatar.jpg &apos;dome&apos;\n</code></pre><h2 id=\"插入图片带有链接\"><a href=\"#插入图片带有链接\" class=\"headerlink\" title=\"插入图片带有链接\"></a>插入图片带有链接</h2><pre><code>[![](/assets/images/avatar.jpg &apos;百度&apos;)](http://www.baidu.com)\n\n[![](/assets/images/avatar.jpg &apos;百度&apos;)][5]\n\n  [5]: http://www.baidu.com\n</code></pre><h2 id=\"视频插入\"><a href=\"#视频插入\" class=\"headerlink\" title=\"视频插入\"></a>视频插入</h2><pre><code>&lt;iframe height=498 width=510 src=&apos;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&apos; frameborder=0 &apos;allowfullscreen&apos;&gt;&lt;/iframe&gt;\n</code></pre><h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><pre><code>|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n|=========|===============|============|\n</code></pre><h2 id=\"序表\"><a href=\"#序表\" class=\"headerlink\" title=\"序表\"></a>序表</h2><pre><code>1. one\n2. two\n3. three\n\n* one\n* two\n  * ww\n* three\n- four\n+ five\n</code></pre><h2 id=\"任务列表\"><a href=\"#任务列表\" class=\"headerlink\" title=\"任务列表\"></a>任务列表</h2><pre><code>- [ ] last\n- [x] first\n</code></pre><h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><pre><code>Markdown[^1]\n\n  [^1]: Markdown是一种纯文本标记语言\n</code></pre><h2 id=\"分隔符\"><a href=\"#分隔符\" class=\"headerlink\" title=\"分隔符\"></a>分隔符</h2><pre><code>***\n---\n* * *\n</code></pre>","slug":"06-29-Markdown 常用语法","updated":"2018-08-31T07:57:39.105Z","comments":true,"link":"","permalink":"http://www.zosion.red/06-29-Markdown 常用语法/","excerpt":"# 快捷键 快捷键 功能 Ctrl + B Toggle bold Ctrl + I Toggle italic Alt + S Toggle strikethrough Ctrl + Shift + ] Toggle heading (uplevel) Ctrl + Shift + [ Toggle heading (downlevel) Alt + C Check/Uncheck task list item","categories":[],"tags":[{"name":"Learning","slug":"Learning","permalink":"http://www.zosion.red/tags/Learning/"}]},{"title":"传说中痴心的眼泪会倾城","date":"2018-06-29T03:24:33.000Z","path":"06-29-传说中痴心的眼泪会倾城/","text":"昨天《渐渐》，今天《倾城》","raw":"---\ntitle: 传说中痴心的眼泪会倾城\ndate: 2018-06-29 11:24:33\ntags: Essays\ncomments: true\n# top: true\n---\n{% img /assets/images/figure/concert.png 2000 %}\n昨天《渐渐》，今天《倾城》\n","content":"<img src=\"/assets/images/figure/concert.png\" width=\"2000\">\n<p>昨天《渐渐》，今天《倾城》</p>\n","slug":"06-29-传说中痴心的眼泪会倾城","updated":"2018-08-30T03:26:10.039Z","comments":true,"link":"","permalink":"http://www.zosion.red/06-29-传说中痴心的眼泪会倾城/","excerpt":"","categories":[],"tags":[{"name":"Essays","slug":"Essays","permalink":"http://www.zosion.red/tags/Essays/"}]}]